{"eventHandlers":{},"isEmptyObject":{"js":"obj => {\n    for (let k in obj) return false;\n    return true;\n}"},"stateUpdateFull":{"js":"async state => {\n        for (let k in s) if (!state[k]) delete s[k];\n        s.merge(s, state);\n        s.l('setUpdate', 'setForUpdate: ', Object.keys(state).length);\n    }"},"loopDelay":2000,"checkUpdatePermission":{"js":"async (path, username, user) => {\n    if (username === 'root') return true;\n\n    let perms = user?._sys_?.permissions;\n    if (!perms) perms = {};\n\n    if (path[0] === 'users') {\n\n        if (path[1] !== username) {\n            if (perms.changeOtherUsers) return true;\n\n            return \"You can't change other users namespaces.\";\n        }\n        if (path[2] === '_sys_') {\n            return \"You can't change system data.\";\n        }\n\n        return true;\n\n    } else {\n        if (perms.changeSys) return true;\n\n        return \"You can't change system namespaces.\";\n    }\n}"},"netUpdate":{"js":"async update => {\n\n    const sys = s.sys;\n    if (!sys) return;\n\n    const updateIds = sys.netUpdateIds;\n    const del = id => setTimeout(() => updateIds.delete(id), 20000);\n\n    let updateId = update.updateId;\n    if (updateId) {\n        updateIds.set(updateId, 1);\n        s.l(`Update received. [${updateId}]`);\n        del(updateId);\n    } else {\n        const newUpdateId = s.f('sys.uuid');\n        updateIds.set(newUpdateId, 1);\n        update.updateId = newUpdateId;\n        del(newUpdateId);\n    }\n\n    const secretsNetNodes = (await sys.getSecrets()).netNodes;\n\n    for (let nodeName in s.net) {\n\n        const node = s.net[nodeName];\n        if (!node.isActive || nodeName === s.sys.netId) {\n            s.l(`netNode skip [${nodeName}]`); continue;\n        }\n        try {\n            const url = node.host ? 'https://' + node.host : 'http://' + node.ip;\n            const http = new (await s.f('sys.httpClient'));\n            const token = secretsNetNodes[nodeName];\n\n            const r = await http.post(url + '/stateUpdate', update, { cookie: `netToken=${token}` });\n            s.l(`netNode update [${nodeName}]`, 'resp:', r.data);\n        } catch (e) {\n            s.l(`error making update of node`,);\n        }\n    }\n}"},"setUpdate":{"js":"async state => {\n\n        const t = s.sys.token;\n        for (let k in s) if (!state[k]) delete s[k];\n        for (let k in state) s[k] = state[k];\n        s.sys.token = t;\n\n        s.def('loadStateDone', 1);\n        s.l('setUpdate', 'setForUpdate: ', Object.keys(state).length, 'set: ', Object.keys(s).length);\n    }"},"rqAuthenticateByToken":{"js":"(rq) => {\n        let {token} = s.sys.rqGetCookies(rq);\n        return token && s.sys.token && token === s.sys.token;\n    }"},"parseCliArgs":{"js":"(cliArgs) => {\n\n        const args = {};\n\n        for (let i = 0; i < cliArgs.length; i++) {\n            if (i < 2) continue; //skip node scriptName args\n\n            let arg = cliArgs[i];\n            let [k, v] = arg.split('=');\n            if (!v) {\n                args[i - 2] = arg; //start write args from main 0\n                continue;\n            }\n            k = k.slice(2); //remove \"--\" characters\n            args[k.trim()] = v.trim();\n        }\n\n        return args;\n    }"},"logger":{"js":"() => {\n    return class Logger {\n        constructor(prefix = '') {\n            this.prefix = prefix;\n            this.isMuted = 0;\n        }\n        mute() { this.isMuted = 1 } unmute() { this.isMuted = 0 }\n        onMessage(handler) { this.handler = handler; return this; }\n\n        async log() {\n            let s = this.prefix + '';\n            \n            for (let i = 0; i < arguments.length; i++) {\n                const m = arguments[i];\n                const isObjOrArray = typeof m === 'object' && m !== null;\n\n                if (m instanceof Error) {\n                    s += m.stack ?? m.toString();\n                } else {\n                    s += isObjOrArray ? ' ' + JSON.stringify(m) : m;\n                }\n            }\n            if (!this.isMuted) console.log(s);\n            if (this.handler) this.handler(s);\n        }\n        async info() { await this.log(...arguments); }\n        async error() { await this.log(...arguments); }\n    }\n}"},"cloneObject":{"js":"obj => {\n\n    //ok\n    if (Array.isArray(obj)) {\n        let array = [];\n        for (let i = 0; i < obj.length; i++) {\n\n            const v = obj[i];\n            const t = typeof v;\n\n            if (t === 'function') continue;\n            if (t === 'object' && v !== null) {\n                array.push(cloneObject(v));\n            } else {\n                array.push(v);\n            }\n        }\n        return array;\n    }\n\n    let clone = {};\n    for (let k in obj) {\n        const v = obj[k];\n        const t = typeof v;\n        if (t === 'function') continue;\n        clone[k] = (t === 'object' && v !== null) ? cloneObject(v) : v;\n    }\n    return clone\n}"},"apps":{"GUI":{"js":"() => {\n    return class GUI {\n\n        async start() {\n            //todo reactivity for deps and realtime updates\n            this.http = new (await s.f('sys.httpClient'));\n            this.v = await s.f('sys.ui.view');\n\n            // const baseUrl = document.location.protocol + '//' + document.location.host;\n            // require.config({ paths: { 'vs': baseUrl + '/node_modules/monaco-editor/min/vs' }});\n            // window.MonacoEnvironment = {\n            //     getWorkerUrl: (workerId, label) => {\n            //         return `data:text/javascript;charset=utf-8,${encodeURIComponent(`\n            //     self.MonacoEnvironment = { baseUrl: '${baseUrl}/node_modules/monaco-editor/min/' };\n            //     importScripts('${baseUrl}/node_modules/monaco-editor/min/vs/base/worker/workerMain.js');`\n            //         )}`;\n            //     }\n            // };\n            // await (new Promise((resolve, reject) => {\n            //     require([\"vs/editor/editor.main\"], () => resolve());\n            // }));\n\n            const input = new (await s.f('sys.ui.input'));\n            input.onKeyDown(e => appsManager.inputEvent('keydown', e));\n            input.onKeyUp(e => appsManager.inputEvent('keyup', e));\n            input.onClick(e => appsManager.inputEvent('click', e));\n            input.onDblClick(e => appsManager.inputEvent('dblclick', e));\n            input.onContextMenu(e => appsManager.inputEvent('contextmenu', e));\n            input.onResize(e => s.e('recalcDimensions'));\n            this.input = input;\n            document.body.addEventListener('touchstart', e => e.preventDefault());\n\n            e['>'] = args => {\n                let [v1, v2, index] = args;\n\n                if (v1.getV) v1 = v1.getV();\n                if (v2.getV) v2 = v2.getV();\n\n                if (index !== undefined) {\n                    v2.getDOM().insertBefore(v1.getDOM(), v2.getDOM().children[index]);\n                    return;\n                }\n                v2.getDOM().append(v1.getDOM());\n            }\n            e['>before'] = (args) => {\n                const [domA, domB] = args;\n                domB.getDOM().before(domA.getDOM())\n            }\n            e['>after'] = (args) => {\n                const [domA, domB] = args;\n                domB.getDOM().after(domA.getDOM())\n            }\n            e['app.addViewElement'] = v => e('>', [v, app]);\n            e['appFrame.changePosition'] = ({ appFrame, x, y }) => {\n                appsManager.appFrameChangePosition(appFrame, x, y);\n            };\n            e['appFrame.changeSize'] = ({ appFrame, width, height }) => {\n                appsManager.appFrameChangeSize(appFrame, width, height);\n            };\n            e['appFrame.close'] = ({ appFrame }) => {\n                appsManager.closeAppFrame(appFrame);\n            };\n            //s.e('appFrame.changePosition', { x, y })\n\n            e['openNode'] = async ({ appPath = 'apps.monacoEditor', outlinerNode }) => {\n                const dataNode = outlinerNode.getDataNode();\n                dataNode.setPath(outlinerNode.getPath().join('.'));\n\n                await appsManager.openApp(appPath, dataNode);\n                appsManager.updateFocusedAppContainerDimensions();\n            }\n            e['outlinerSizeChanged'] = outlinerWidth => {\n\n                localState.setOutlinerWidth(outlinerWidth);\n\n                const appContainerWidth = window.innerWidth - outlinerWidth.width;\n                appsManager.setWidth(appContainerWidth);\n            }\n            e['input.pointer.setHandlers'] = ({ down, move, up }) => {\n                this.input.onPointerMove(move);\n                this.input.onPointerUp(up);\n            }\n            e['recalcDimensions'] = () => {\n                mainContainer.setSize(globalThis.innerWidth, globalThis.innerHeight);\n            }\n            e['state.update'] = async ({ outlinerNode, dataNode, data }) => {\n\n                //todo send here only path and data\n\n                if (!dataNode) dataNode = outlinerNode.getDataNode();\n                dataNode.setData(data);\n\n                let path, k;\n                if (outlinerNode) {\n                    path = outlinerNode.getPath();\n                    if (!path || path.length < 1) return;\n\n                    const parentDataNode = outlinerNode.getParent().getDataNode();\n                    k = path.at(-1);\n                    parentDataNode.set(k, data);\n                } else {\n                    path = dataNode.getPath();\n                    if (typeof path === 'string') {\n                        path = path.split('.');\n                    }\n                    const parent = path.length > 1 ? s.find(path.slice(0, -1)) : s;\n                    k = path.at(-1);\n                    if (parent && k) parent[k] = data;\n                }\n                if (path) {\n                    await this.http.post('/stateUpdate', { cmds: [{ path, v: data, op: 'set' }] });\n                    if (k === 'js') {\n                        const { parent } = s.findParentAndK(path);\n                        if (parent) delete parent[s.sys.SYMBOL_FN];\n                    }\n                }\n            }\n            e['state.del'] = async ({ outlinerNode, dataNode }) => {\n                //todo case  for dataNode\n                const path = outlinerNode.getPath();\n                await this.http.post('/stateUpdate', { cmds: [{ path, op: 'rm' }] });\n\n                const parentOutlinerNode = outlinerNode.getParent();\n                const parentDataNode = parentOutlinerNode.getDataNode();\n                parentDataNode.del(path.at(-1));\n\n                if (parentDataNode.isEmpty()) parentOutlinerNode.openCloseBtnHide();\n                outlinerNode.remove();\n            }\n            e['state.updateReceive'] = (update) => {\n                s.l(update);\n            }\n            s.e['outlinerNode.find'] = id => {\n                const node = this.outliner.nodes.get(id);\n                if (!node) {\n                    s.l(id, this.outliner.nodes);\n                }\n                return node;\n            }\n            e['localState.set'] = d => {\n                let [k, v] = d;\n                if (!k || typeof v === 'object') return;\n                localState.set(k, v);\n            }\n            e['localState.get'] = k => localState.get(k);\n\n            const localState = new (await s.f('sys.apps.GUI.localState'));\n\n            //console.log(await s.f('sys.apps.fileUploader'));\n\n            //BUILDING UI\n            const app = new this.v;\n            app.setDOM(document.getElementById('app'));\n\n\n            const runBtn = new this.v({ class: 'burger-btn' });\n            e('>', [runBtn, app]);\n            [1, 1, 1].forEach(() => e('>', [new this.v({ class: 'burger-line' }), runBtn]));\n\n            runBtn.on('pointerdown', (e) => {\n                e.stopPropagation();\n                runBtn.addClass('active');\n\n                const popup = s.sys.popup; popup.clear();\n                const createBtn = (txt) => new this.v({ txt, class: ['btn', 'contextMenu', 'white', 'hoverGray'] });\n\n                let oBtn = createBtn('Auth');\n                oBtn.on('click', () => {\n                    appsManager.openApp('sys.apps.auth', null, true);\n                    popup.clear();\n                });\n                //oBtn.on('pointerenter', removeSubmenu);\n                window.e('>', [oBtn, popup]);\n\n                oBtn = createBtn('Data browser');\n                oBtn.on('click', () => {\n                    appsManager.openApp('sys.apps.dataBrowser', null, true);\n                    popup.clear();\n                });\n                //oBtn.on('pointerenter', removeSubmenu);\n                window.e('>', [oBtn, popup]);\n\n                oBtn = createBtn('Terminal');\n                oBtn.on('click', () => {\n                    appsManager.openApp('sys.apps.terminal', null, true);\n                    popup.clear();\n                });\n                window.e('>', [oBtn, popup]);\n\n                popup.putRightTo(runBtn);\n            });\n\n            //todo rename this to appContainer and create it inside appsManager\n            const mainContainer = new this.v({ class: ['mainContainer'] });\n            mainContainer.on('pointerdown', (e) => s.sys.popup.clear());\n            this.mainContainer = mainContainer;\n            e('>', [mainContainer, app]);\n\n            const appsManager = new (await s.f('sys.apps.GUI.appsManager'));\n            try {\n                await appsManager.init(mainContainer);\n            } catch (e) {\n                alert(e.toString() + e.stack);\n            }\n\n            s.sys.popup = new (await s.f('sys.apps.GUI.popup'));\n            e('>', [s.sys.popup, app]);\n\n            s.e('recalcDimensions');\n\n            const es = new EventSource('/stream');\n            es.onmessage = event => {\n\n                let data = {};\n                try {\n                    data = JSON.parse(event.data);\n                } catch (e) {\n                    console.error(e);\n                    return;\n                }\n                if (data.logMsg) {\n                    s.e('terminal.logMsg', data.logMsg);\n                } else if (data.statUpdate) { }\n            }\n            es.onerror = (e) => s.l('An error occurred while attempting to connect.', e);\n        }\n    }\n}","html":{"js":"async () => {\n\n    return `\n\n<!DOCTYPE html>\n<html lang=\"en\" data-theme=\"light\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n    <title>VOS</title>\n    <link rel=\"icon\" href=\"data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>âœ¨</text></svg>\">\n    <style>\n        :root {\n            --bg-color: white;\n            --keyword-color: #0033B3;\n            --name-color: #248F8F;\n            --op-color: black;\n            --string-color: #067D17;\n            --number-color: #1750EB;\n            --prop-name-color: #971796;\n            --function-color: #A77C43;\n            --bracket-color: black;\n            --standart-line-height: 1.55em;\n            --shift: 1.2em;\n        }\n        :root .prose {\n            --tw-prose-body: hsla(var(--bc)/.8);\n            --tw-prose-headings: hsl(var(--bc));\n            --tw-prose-lead: hsl(var(--bc));\n            --tw-prose-links: hsl(var(--bc));\n            --tw-prose-bold: hsl(var(--bc));\n            --tw-prose-counters: hsl(var(--bc));\n            --tw-prose-bullets: hsla(var(--bc)/.5);\n            --tw-prose-hr: hsla(var(--bc)/.2);\n            --tw-prose-quotes: hsl(var(--bc));\n            --tw-prose-quote-borders: hsla(var(--bc)/.2);\n            --tw-prose-captions: hsla(var(--bc)/.5);\n            --tw-prose-code: hsl(var(--bc));\n            --tw-prose-pre-code: hsl(var(--nc));\n            --tw-prose-pre-bg: hsl(var(--n));\n            --tw-prose-th-borders: hsla(var(--bc)/.5);\n            --tw-prose-td-borders: hsla(var(--bc)/.2)\n        }\n        [data-theme=light] {\n            color-scheme: light;\n            --bg-color: hsl(var(--b2, var(--b1)));\n            --pf: 258.89 94.378% 40.941%;\n            --sf: 314 100% 37.647%;\n            --af: 174 60% 40.784%;\n            --nf: 219 14.085% 22.275%;\n            --in: 198 93% 60%;\n            --su: 158 64% 52%;\n            --wa: 43 96% 56%;\n            --er: 0 91% 71%;\n            --inc: 198 100% 12%;\n            --suc: 158 100% 10%;\n            --wac: 43 100% 11%;\n            --erc: 0 100% 14%;\n            --rounded-box: 1rem;\n            --rounded-btn: .5rem;\n            --rounded-badge: 1.9rem;\n            --animation-btn: .25s;\n            --animation-input: .2s;\n            --btn-text-case: uppercase;\n            --btn-focus-scale: .95;\n            --border-btn: 1px;\n            --tab-border: 1px;\n            --tab-radius: .5rem;\n            --p: 258.89 94.378% 51.176%;\n            --pc: 0 0% 100%;\n            --s: 314 100% 47.059%;\n            --sc: 0 0% 100%;\n            --a: 174 60% 50.98%;\n            --ac: 174.71 43.59% 15.294%;\n            --n: 219 14.085% 27.843%;\n            --nc: 0 0% 100%;\n            --b1: 0 0% 100%;\n            --b2: 0 0% 94.902%;\n            --b3: 180 1.9608% 90%;\n            --bc: 215 27.907% 16.863%;\n        }\n        html { overflow: hidden; }\n        body {\n            overflow: hidden;\n            margin: 0;\n            position: relative;\n            color: hsl(var(--bc));\n            font-family: Helvetica, Tahoma, Arial, sans-serif;\n            font-size: 15px;\n            /* background: var(--bg-color); */\n            -webkit-text-size-adjust: 100%;\n        }\n        .popup {\n            position: absolute;\n            opacity: 0.97;\n            z-index: 5;\n            box-shadow: rgba(0, 0, 0, 0.50) 0px 2px 8px;\n        }\n        .popup .btn.contextMenu {\n            color: hsl(var(--bc));\n            padding-right: 30px;\n        }\n        /*.pageSign {*/\n        /*    display: flex;*/\n        /*    justify-content: center;*/\n        /*    justify-self: center;*/\n        /*}*/\n        /*.signContainer {*/\n        /*    display: flex;*/\n        /*    justify-content: center;*/\n        /*    width: 15em;*/\n        /*    margin-top: 5em;*/\n        /*    padding: 25px;*/\n        /*    background: #dcdde1;*/\n        /*}*/\n        /*.signBlock input { width: 15em; }*/\n\n        .runBtn {\n            width: 1.3em;\n            height: 0.8em;\n            background: rgba(18,199,5,0.99);\n        }\n        .dataBrowser {\n            background: #ededed;\n            padding: 0 7px;\n            height: 100%;\n            overflow: scroll;\n        }\n        .dataBrowser > .node > .nodeContainer > .openClose { display: none; }\n        .nodeContainer .quote { color: #AA1011; }\n\n        .authApp {\n            background: #ededed;\n            height: 100%;\n            display: flex;\n            justify-content: center;\n            align-items: start;\n            gap: 0.5em;\n            padding-top: 1em;\n        }\n\n        .dataValue.string {\n            min-height: 10px;\n            min-width: 2px;\n        }\n\n        .appFrame {\n            position: absolute;\n            top: 30px;\n            box-shadow: 0 2px 4px 0 rgba(0,0,0,0.2);\n            overflow: hidden;\n        }\n\n        /* this create small glitches when after start and drag window */\n        .appFrame.drag {\n            -webkit-touch-callout: none; /* iOS Safari */\n            -webkit-user-select: none;   /* Chrome/Safari/Opera */\n            -khtml-user-select: none;    /* Konqueror */\n            -moz-user-select: none;      /* Firefox */\n            -ms-user-select: none;       /* Internet Explorer/Edge*/\n            user-select: none;\n        }\n        .appTopBar {\n            width: 100%;\n            display: flex;\n            align-items: center;\n            padding: 5px 0;\n            background: lightgray;\n            cursor: pointer;\n            box-shadow: 0 2px 4px 0 rgba(0,0,0,0.2);\n        }\n        .appFrame.drag .appTopBar {\n            cursor: move;\n        }\n        .appTitle {\n            font-weight: bold;\n            white-space: nowrap;\n            margin-left: 5px;\n        }\n        .resizer {\n            position: absolute;\n            min-width: 1em;\n            min-height: 1em;\n        }\n        .resizeTop {\n            left: 0.5em;\n            right: 0.5em;\n            top: -0.5em;\n            cursor: ns-resize;\n        }\n        .resizeBottom {\n            left: 0.5em;\n            right: 0.5em;\n            bottom: -0.5em;\n            cursor: ns-resize;\n        }\n        .resizeLeft {\n            top: 0.5em;\n            bottom: 0.5em;\n            left: -0.5em;\n            cursor: ew-resize;\n        }\n        .resizeRight {\n            top: 0.5em;\n            bottom: 0.5em;\n            right: -0.5em;\n            cursor: ew-resize;\n        }\n        .resizeTopLeft {\n            top: -0.5em;\n            left: -0.5em;\n            cursor: nwse-resize;\n        }\n        .resizeTopRight {\n            top: -0.5em;\n            right: -0.5em;\n            cursor: nesw-resize;\n        }\n        .resizeBottomLeft {\n            bottom: -0.5em;\n            left: -0.5em;\n            cursor: nesw-resize;\n        }\n        .resizeBottomRight {\n            bottom: -0.5em;\n            right: -0.5em;\n            cursor: nwse-resize;\n        }\n\n        .openClose {\n            display: flex;\n            align-items: center;\n            margin-right: 5px;\n            line-height: 10px;\n            color: #656565;\n            cursor: pointer;\n        }\n        .openClose > .openCloseArrow {\n            width: 10px;\n            height: 10px;\n            background-image: url(\"data:image/svg+xml,%3Csvg fill='%23000000' width='100%' height='100%' version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 407.36 407.36' xml:space='preserve'%3E%3Cg id='SVGRepo_bgCarrier' stroke-width='0'%3E%3C/g%3E%3Cg id='SVGRepo_tracerCarrier' stroke-linecap='round' stroke-linejoin='round'%3E%3C/g%3E%3Cg id='SVGRepo_iconCarrier'%3E%3Cpolygon points='112.814,0 91.566,21.178 273.512,203.718 91.566,386.258 112.814,407.436 315.869,203.718 '%3E%3C/polygon%3E%3C/g%3E%3C/svg%3E\");\n            background-repeat: no-repeat;\n        }\n        .openClose.opened { transform: rotate(90deg); }\n        .opsBtn {\n            cursor: pointer;\n            color: black;\n        }\n\n        .tabs {\n            display: flex;\n            min-height: 30px;\n            background: var(--bg-color);\n            border-bottom: 1px solid lightgray;\n        }\n        .tab {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            column-gap: 5px;\n            padding: 5px 10px;\n            cursor: pointer;\n        }\n        .tab.active { background: #FFFFFF; }\n        .tab.error { background: lightcoral; }\n        .tabHeader {\n            color: black;\n            cursor: pointer;\n            padding: 5px 5px;\n            background: rgb(236, 236, 236);\n            font-weight: bold;\n            gap: 5px;\n        }\n        .tabHeader.active {\n            background: white;\n            color: black;\n        }\n        .tabCloseBtn {\n            margin-left: 5px;\n            width: 0.8em;\n            height: 0.8em;\n            border-radius: 100px;\n            background: rgb(221 131 131 / 99%);\n        }\n\n        .terminal {\n            height: 100%;\n            background: hsl(var(--b2));\n            overflow: scroll;\n            -webkit-overflow-scrolling: touch;\n        }\n        .terminal .scrollBlock {\n            white-space: nowrap;\n        }\n        .terminal .consoleCmd {\n            outline: none;\n            border: 1px solid #969696;\n            color: black;\n        }\n        .terminal pre {\n            margin: 0;\n            white-space: -moz-pre-wrap; /* Mozilla, supported since 1999 */\n            white-space: -pre-wrap; /* Opera */\n            white-space: -o-pre-wrap; /* Opera */\n            white-space: pre-wrap; /* CSS3 - Text module (Candidate Recommendation) http://www.w3.org/TR/css3-text/#white-space */\n            word-wrap: break-word; /* IE 5.5+ */\n        }\n        .terminal .consoleHeader {\n            display: flex;\n            position: sticky;\n            top: 0;\n            background: #B3E5BE;\n            gap: 10px;\n        }\n        [contenteditable] {outline: 0; }\n        [contenteditable]:focus {}\n\n        .shift { margin-left: calc( var(--shift) * 1 ); }\n        .shift1 { margin-left: calc( var(--shift) * 1 ); }\n        .shift2 { margin-left: calc( var(--shift) * 2 ); }\n        .shift3 { margin-left: calc( var(--shift) * 3 ); }\n        .shift4 { margin-left: calc( var(--shift) * 4 ); }\n        .shift5 { margin-left: calc( var(--shift) * 5 ); }\n        .shift6 { margin-left: calc( var(--shift) * 6 ); }\n        .shift7 { margin-left: calc( var(--shift) * 7 ); }\n        .shift8 { margin-left: calc( var(--shift) * 8 ); }\n        .shift9 { margin-left: calc( var(--shift) * 9 ); }\n        .shift10 { margin-left: calc( var(--shift) * 10 ); }\n\n        .monacoEditor {\n            /*position: absolute;*/\n            height: 100%;\n            font-family: 'JetBrains Mono', sans-serif;\n            line-height: 1.55em;\n            font-size: 13.7px;\n            /*min-height: 100vh;*/\n            /*min-width: 50vh;*/\n        }\n        /*.monacoEditor * { font-variant-ligatures : none; }*/\n\n        input {\n            font-family: 'Roboto', sans-serif;\n            font-size: 15px;\n        }\n        input.scriptName {\n            border: 1px solid black;\n            color: black;\n            padding: 3.5px;\n            background: rgb(170 191 222);\n        }\n\n        .hidden { display: none !important; }\n        .visibilityHidden { visibility: hidden; }\n        .grid { display: grid; }\n        .flex { display: flex; }\n        .inlineBlock { display: inline-block; }\n        .gap { gap: 10px; }\n        .alignCenter { align-items: center; }\n        .margin10 { margin-left: 10px; }\n        .cursorPointer { cursor: pointer; }\n\n        .btn {\n            padding: 2px 4px;\n            --tw-bg-opacity: 1;\n            background: hsl(var(--n)/var(--tw-bg-opacity));\n            --tw-text-opacity: 1;\n            color: hsl(var(--nc)/var(--tw-text-opacity));\n            cursor: pointer;\n            text-decoration: none;\n            font-weight: normal;\n            white-space: nowrap;\n        }\n        .btn.white {\n            background: white;\n        }\n        .btn:active {\n            transform: scale(var(--btn-focus-scale,.95));\n        }\n        .btn.hoverGray:hover {\n            background: #d9d9d9;\n        }\n        .burger-btn {\n            position: absolute;\n            display: flex;\n            flex-direction: column;\n            width: 21px;\n            height: 19px;\n            gap: 3px;\n            border: none;\n            cursor: pointer;\n        }\n        .burger-line {\n            height: 3px;\n            background: #000;\n        }\n        .btnsBar {\n            display: flex;\n            align-items: center;\n            background: #F3F3F3;\n        }\n        .rotate180 { transform: rotate(180deg); }\n    </style>\n</head>\n<body>\n\n<div id=\"app\"></div>\n\n<script>${s['js']}</script>\n</body>\n</html>\n`\n\n}"},"appContainer":{"js":"async () => {\n    return class AppContainer {\n\n        constructor(app, appPath, dataNode, TabClass, viewClass) {\n            this.id = s.f('sys.uuid');\n            this.app = app;\n            this.appPath = appPath;\n            this.dataNode = dataNode;\n\n            this.v = new viewClass({id: this.id, class: ['appContainer']});\n            e('>', [app.getV(), this.v]);\n\n            let tabName = this.dataNode.getPath().split('.').slice(-2);\n            this.tab = new TabClass(this.id, tabName.join('.'));\n        }\n\n        getId() { return this.id; }\n        getV() { return this.v; }\n\n        // getApp() { return this.app; }\n        // getAppPath() { return this.appPath; }\n        getDataNode() { return this.dataNode; }\n        getTab() { return this.tab; }\n\n        hightLightErr() { this.tab.hightLightErr(); }\n        unHightlightErr() { this.tab.unHightlightErr(); }\n\n        activate() {\n            this.v.show();\n            this.tab.activate();\n            this.app.activate();\n        }\n        deactivate() {\n            this.v.hide();\n            this.tab.deactivate();\n            this.app.deactivate();\n        }\n\n        setWidth(width) { this.v.setStyles({width: width + 'px'}); }\n        setHeight(height) { this.v.setStyles({height: height + 'px'}); }\n\n        onClick(fn) { this.tab.onTabClick(fn); }\n        onClickClose(fn) { this.tab.onTabCloseClick(fn); }\n        close() {\n            this.tab.close();\n            this.app.close();\n        }\n    }\n}"},"appsManager":{"js":"() => {\n    return class AppsManager {\n\n        async init(uiContainer) {\n\n            this.uiContainer = uiContainer;\n            this.openedApps = [];\n\n            let lsOpenedApps = s.e('localState.get', 'openedApps'); //localStateOpenedApps\n            if (!lsOpenedApps) return;\n            lsOpenedApps = JSON.parse(lsOpenedApps);\n\n            for (let i = 0; i < lsOpenedApps.length; i++) {\n\n                const { appPath, dataPath, dimensions } = lsOpenedApps[i];\n\n                let dataNode;\n                if (dataPath) {\n                    const node = s.find(dataPath);\n                    if (node) {\n                        //todo delete from localState\n                        //this.localState.setOpenedApps(this.openedApps);\n                        //const dataNode = new DataNode(node);\n                        //dataNode.setPath(dataPath);\n                    } else {\n                        //deleteFromLocal storage\n                    }\n                }\n                const appFrame = await this.openApp(appPath, dataNode, false);\n                appFrame.setPosition(dimensions.x, dimensions.y);\n                appFrame.setSize(dimensions.width, dimensions.height);\n                appFrame.recalcDimensions();\n            }\n        }\n        async inputEvent(t, e) {\n            if (!this.focusedAppFrame) return;\n\n            const app = this.focusedAppFrame.getApp();\n\n            if (t === 'click' && app.handleClick) app.handleClick(e);\n            else if (t === 'contextmenu' && app.handleContextmenu) app.handleContextmenu(e);\n            else if (t === 'keydown' && app.handleKeydown) app.handleKeydown(e);\n            else if (t === 'keyup' && app.handleKeyup) app.handleKeyup(e);\n            else if (t === 'blclick' && app.handleDblclick) app.handleDblclick(e);\n        }\n        async appFrameChangePosition(appFrame, x, y) {\n            this.saveOpenedApps();\n        }\n        async appFrameChangeSize(appFrame, width, height) {\n            this.saveOpenedApps();\n        }\n\n        async openApp(appPath, dataNode, addToLocalState) {\n\n            const v = await s.f('sys.ui.view');\n            //this can be cached with subscription on change, change protos in real time\n\n            const appFrame = Object.create(s.f('sys.apps.GUI.appFrame'));\n            await appFrame.init(appPath, dataNode, v);\n            appFrame.setIndex(this.openedApps.length);\n\n            s.l(this.openedApps.length);\n\n            e('>', [appFrame.getView(), this.uiContainer]);\n\n            appFrame.getView().on('click', (e) => this.focusAppFrame(appFrame));\n            appFrame.getView().on('contextmenu', (e) => this.focusAppFrame(appFrame));\n            this.openedApps.push(appFrame);\n\n            if (addToLocalState) {\n                //use this methods manually. after this skip and remove flag \"addToLocalState\"\n                appFrame.setDefaultSize();\n                this.saveOpenedApps();\n            }\n            appFrame.recalcDimensions();\n\n            this.focusedAppFrame = appFrame;\n\n            return appFrame;\n        }\n        saveOpenedApps() {\n\n            const arr = [];\n\n            this.openedApps.forEach(appFrame => {\n\n                const sizes = appFrame.getSizes();\n                arr.push({\n                    appPath: appFrame.getAppPath(),\n                    dataPath: appFrame.getDataPath(),\n                    dimensions: {\n                        x: sizes.x,\n                        y: sizes.y,\n                        width: sizes.width,\n                        height: sizes.height\n                    },\n                });\n            });\n            s.e('localState.set', ['openedApps', JSON.stringify(arr)]);\n        }\n        focusAppFrame(appFrame) {\n            if (this.focusedAppFrame) {\n                // if (this.activeTab.getContextNodeId() === tab.getContextNodeId()) {\n                //     return;\n                // }\n                //this.focusedApp.deactivate();\n            }\n            this.focusedAppFrame = appFrame;\n            //appFrame.activate();\n            //this.localState.s(appContainer.getId());\n        }\n        closeAppFrame(appFrame) {\n            this.openedApps.splice(appFrame.getIndex(), 1);\n            this.saveOpenedApps();\n        }\n        getFocusedApp() { return this.focusedApp; }\n        getV() { return this.v }\n    }\n}"},"localState":{"js":"async () => {\n    return class LocalState {\n\n        constructor() {\n            const openedAppsJSON = localStorage.getItem('openedApps');\n            this.openedApps = openedAppsJSON ? JSON.parse(openedAppsJSON) : {};\n        }\n        setOpenedApps(openedApps) {\n            localStorage.setItem('openedApps', JSON.stringify(openedApps));\n        }\n        getOpenedApps() {\n            const str = localStorage.getItem('openedApps');\n            if (str) return JSON.parse(str);\n            return [];\n        }\n\n        setActiveTabId(tabId) { localStorage.setItem('activeTabId', tabId); }\n        getActiveTabId() { return localStorage.getItem('activeTabId'); }\n\n        setOutlinerWidth(v) { localStorage.setItem('outlinerWidth', v); }\n        getOutlinerWidth() { return localStorage.getItem('outlinerWidth'); }\n\n        getLogPanelHeight() { return localStorage.getItem('logPanelHeight'); }\n        setLogPanelHeight(v) { localStorage.setItem('logPanelHeight', v); }\n\n        get(k) { return localStorage.getItem(k); }\n        set(k, v) { localStorage.setItem(k, v); }\n        del(k) { localStorage.removeItem(k); }\n    }\n\n}"},"dataNode":{"js":"async () => {\n    return class DataNode {\n        constructor(data) { this.data = data }\n        setKey(key) { this.key = key }\n        getKey() { return this.key }\n\n        getPath() { return this.path; }\n        setPath(path) { this.path = path; }\n\n        getData() { return this.data }\n        setData(data) { this.data = data; }\n\n        getDataType() { return typeof this.data }\n        get(k) { return this.data[k] }\n        set(k, v) { this.data[k] = v }\n        del(k) { delete this.data[k] }\n        isEmpty() {\n            return Object.keys(this.data).length === 0;\n        }\n    }\n}"},"tab":{"js":"async () => {\n    return class TabName {\n        constructor(tabId, name) {\n\n            const v = s.f('sys.ui.view');\n            this.v = new v({id: tabId, class: 'tab'});\n\n            this.name = new v({class: 'tabName', txt: name});\n            e('>', [this.name, this.v]);\n            this.closeBtn = new v({class: 'tabCloseBtn'});\n            e('>', [this.closeBtn, this.v]);\n\n        }\n        hightLightErr() { this.v.addClass('error'); }\n        unHightlightErr() { this.v.removeClass('error'); }\n\n        getOutlinerNode() { return this.outlinerNode; }\n        activate() { this.v.addClass('active'); }\n        deactivate() { this.v.removeClass('active'); }\n        onTabClick(fn) { this.v.on('click', e => fn(e)); }\n        onTabCloseClick(fn) {\n            this.closeBtn.on('click', e => {\n                fn(e, this.closeBtn.parent().getDOMIndex());\n            });\n        }\n        close() { this.v.removeFromDom(); }\n        getV() { return this.v; }\n    }\n}"},"popup":{"js":"() => {\n    return class popup {\n\n        constructor() {\n            const v = s.f('sys.ui.view');\n            this.v = new v({ class: 'popup' });\n        }\n        clear() {\n            this.v.clear();\n            if (this.clearCallback) this.clearCallback();\n            this.clearCallback = null;\n        }\n        remove() { this.v.remove(); }\n        onClear(cb) { this.clearCallback = cb; }\n\n        setDimensions(width, height) {\n            this.v.setStyles({\n                width: width + 'px',\n                height: height + 'px',\n            });\n        }\n\n        putRightTo(v) {\n            const sizes = v.getSizesAbsolute();\n            this.v.setStyles({ top: sizes.top + 'px', left: sizes.right + 'px' });\n        }\n        putRightToPointer(pointer) {\n            //todo scroll?\n            this.v.setStyles({ left: pointer.x + 8 + 'px', top: pointer.y + 'px' });\n        }\n        getV() { return this.v; }\n    }\n\n}"},"terminal":{"js":"async () => {\n    return class Terminal {\n\n        constructor(localState, input) {\n            const v = s.f('sys.ui.view');\n\n            this.v = new v({class: 'terminal'});\n            this.header = new v({class: 'consoleHeader'});\n            e('>', [this.header, this.v]);\n            \n            e('>', [new v({txt: 'Terminal', style: {fontWeight: 'bold'}}), this.header]);\n\n            const clear = new v({txt: 'clear', class: ['btn', 'cursorPointer']});\n            clear.on('click', e => this.content.clear());\n            e('>', [clear, this.header]);\n\n            const scrollContainer = new v({class: ['scrollContainer', 'flex']});\n            e('>', [scrollContainer, this.header]);\n\n            this.automaticScroll = new v({tagName: 'input'});\n            this.automaticScroll.setAttr('type', 'checkbox');\n            this.automaticScroll.setAttr('checked', 'true');\n\n            e('>', [this.automaticScroll, scrollContainer]);\n            e('>', [new v({txt: 'automatic scroll'}), scrollContainer]);\n\n            //const http = new (s.f('sys.httpClient'));\n            // const file = new v({tagName: 'input'});\n            // file.setAttr('type', 'file');\n            // e('>', [file, this.header]);\n            // file.on('change', e => {\n            //     const reader = new FileReader;\n            //     reader.onload = async () => {\n            //         s.l(await http.postBuf('/uploadFile', reader.result));\n            //     }\n            //     reader.readAsArrayBuffer(file.getDOM().files[0]);\n            // });\n\n            const cmds = {\n                outlinerHide: () => {\n                    //\n                }\n            };\n            const consoleCmd = new v({tagName: 'input', class: ['nooutline', 'consoleCmd']});\n            this.consoleCmd = consoleCmd;\n            consoleCmd.setAttr('placeholder', 'cmd');\n            consoleCmd.on('keydown', (e) => {\n                if (e.key !== 'Enter') return;\n                const v = e.target.value;\n\n                //autocomplete for commands\n                if (v === 'outliner.hide') {\n                    localState.set('outlinerHidden', 1);\n                    //outliner hide\n                }\n                if (v === 'outliner.show') {\n                    localState.del('outlinerHidden');\n                }\n            });\n            consoleCmd.on('keyup', (e) => {\n\n            });\n            e('>', [consoleCmd, this.v]);\n\n            this.content = new v({class: 'processLogContent'});\n            e('>', [this.content, this.v]);\n\n            const height = Number(localState.getLogPanelHeight());\n            if (height && height < window.innerHeight) {\n                this.content.setStyles({height: height + 'px'});\n            } else {\n                this.content.setStyles({height: '100px'});\n                localState.setLogPanelHeight(100);\n            }\n\n            this.input = input;\n            this.localState = localState;\n\n            this.dragAndDrop();\n        }\n\n        init() { e('terminalSizeChanged', this.v.getSizes().height); }\n        getHeight() { return this.v.getSizes().height; }\n\n        dragAndDrop() {\n            let headerSizes;\n            let consoleCmdSizes;\n            let shift;\n\n            const pointerMove = (e) => {\n                const mouseY = e.clientY;\n                if (mouseY < headerSizes.height) {\n                    this.content.setStyles({height: window.innerHeight - headerSizes.height - consoleCmdSizes.height + 'px'});\n                    return;\n                }\n                const contentHeight = window.innerHeight - mouseY - headerSizes.height - consoleCmdSizes.height + shift;\n                this.content.setStyles({height: contentHeight + 'px'});\n\n                window.e('terminalSizeChanged');\n            }\n            this.header.on('pointerdown', (e) => {\n                e.preventDefault();\n                headerSizes = this.header.getSizes();\n                consoleCmdSizes = this.consoleCmd.getSizes();\n                shift = e.clientY - headerSizes.y;\n\n                this.input.onMouseMove(pointerMove);\n                this.input.onMouseUp(() => {\n                    this.input.onMouseUp(null);\n                    this.input.onMouseMove(null);\n                    this.localState.setLogPanelHeight(this.content.getSizes().height);\n                });\n            });\n        }\n\n        getV() { return this.v; }\n        show() {\n            this.v.show();\n        }\n        hide() {\n            this.v.hide();\n            window.e('terminalSizeChanged');\n        }\n        switchVisibility() { this.v.isShowed() ? this.v.hide() : this.v.show(); }\n\n        addMsg() {\n\n\n        }\n\n        enableAutomaticScroll() { this.automaticScroll.setAttr('checked', ''); }\n}\n    \n}"},"appFrame":{"js":"() => {\n    const appFrameProto = {\n\n        getApp() { return this.app; },\n        getAppPath() { return this.appPath; },\n        getDataPath() { return this.dataPath; },\n        getView() { return this.view; },\n\n        setIndex(index) { this.index = index; },\n        getIndex() { return this.index; },\n\n        async init(appPath, dataNode, v) {\n\n            this.view = new v({ class: 'appFrame' });\n            this.view.setSize(500, 500);\n            this.app = new (await s.f(appPath));\n            this.appPath = appPath;\n\n            const topBar = new v({ class: ['appTopBar'] });\n            this.topBar = topBar;\n            e('>', [topBar, this.view]);\n            topBar.on('pointerdown', (e) => this.topBarDragAndDrop(e));\n\n            const closeBtn = new v({ class: 'tabCloseBtn' });\n            e('>', [closeBtn, topBar]);\n            closeBtn.on('click', () => {\n                this.view.remove();\n                if (this.app.close) {\n                    this.app.close();\n                }\n                s.e('appFrame.close', { appFrame: this });\n            });\n\n            //todo if not get title, use last part of appPath\n            const title = new v({ txt: this.app.getTitle(), class: 'appTitle' });\n            e('>', [title, topBar]);\n\n            const content = new v({ class: 'appContent' });\n            this.content = content;\n            e('>', [content, this.view]);\n\n            await this.app.init();\n            e('>', [this.app.getV(), content]);\n\n            const resizeTop = new v({ class: ['resizer', 'resizeTop'] });\n            e('>', [resizeTop, this.view]);\n            resizeTop.on('pointerdown', (e) => this.resizeTop(e, resizeTop));\n\n            const nsResizeBottom = new v({ class: ['resizer', 'resizeBottom'] });\n            e('>', [nsResizeBottom, this.view]);\n            nsResizeBottom.on('pointerdown', (e) => this.resizeBottom(e));\n\n            const nsResizeLeft = new v({ class: ['resizer', 'resizeLeft'] });\n            e('>', [nsResizeLeft, this.view]);\n            nsResizeLeft.on('pointerdown', (e) => this.resizeLeft(e));\n\n            const resizeRight = new v({ class: ['resizer', 'resizeRight'] });\n            e('>', [resizeRight, this.view]);\n            resizeRight.on('pointerdown', (e) => this.resizeRight(e));\n\n            const resizeTopLeft = new v({ class: ['resizer', 'resizeTopLeft'] });\n            e('>', [resizeTopLeft, this.view]);\n            resizeTopLeft.on('pointerdown', (e) => this.resizeTopLeft(e));\n\n            const resizeTopRight = new v({ class: ['resizer', 'resizeTopRight'] });\n            e('>', [resizeTopRight, this.view]);\n            resizeTopRight.on('pointerdown', (e) => this.resizeTopRight(e));\n\n            const resizeBottomLeft = new v({ class: ['resizer', 'resizeBottomLeft'] });\n            e('>', [resizeBottomLeft, this.view]);\n            resizeBottomLeft.on('pointerdown', (e) => this.resizeBottomLeft(e));\n\n            const resizeBottomRight = new v({ class: ['resizer', 'resizeBottomRight'] });\n            e('>', [resizeBottomRight, this.view]);\n            resizeBottomRight.on('pointerdown', (e) => this.resizeBottomRight(e));\n        },\n        recalcDimensions() {\n            const height = this.view.getSizes().height - this.topBar.getSizes().height;\n            this.content.setSize(null, height);\n        },\n        setPosition(x, y) { this.view.setPosition(x, y); },\n        setSize(width, height) { this.view.setSize(width, height); },\n        getSizes() { return this.view.getSize(); },\n        setDefaultSize() {\n            if (this.app.getDefaultSize) {\n                const { width, height } = this.app.getDefaultSize();\n                this.setSize(width, height);\n            }\n        },\n        topBarDragAndDrop(e) {\n            const viewSizes = this.view.getSizes();\n            const shift = { x: e.clientX - viewSizes.x, y: e.clientY - viewSizes.y };\n            this.view.addClass('drag');\n\n            s.e('input.pointer.setHandlers', {\n                move: e => {\n                    const x = e.clientX - shift.x;\n                    const y = e.clientY - shift.y;\n                    this.view.setPosition(x, y);\n                    s.e('appFrame.changePosition', { appFrame: this, x, y });\n                },\n                up: (e) => {\n                    s.e('input.pointer.setHandlers', { move: null, up: null });\n                    this.view.removeClass('drag');\n                }\n            });\n        },\n        resizeTop(e) {\n\n            const sizes = this.view.getSizes();\n\n            const maxY = sizes.y + sizes.height;\n            this.view.addClass('drag');\n\n            s.e('input.pointer.setHandlers', {\n                move: e => {\n                    const height = maxY - (e.clientY);\n                    this.view.setSize(null, height);\n                    this.view.setPosition(null, e.clientY);\n\n                    this.recalcDimensions();\n                    s.e('appFrame.changeSize', { appFrame: this, height });\n                    s.e('appFrame.changePosition', { appFrame: this, y: e.clientY });\n                },\n                up: (e) => {\n                    s.e('input.pointer.setHandlers', { move: null, up: null });\n                    this.view.removeClass('drag');\n                }\n            });\n        },\n        resizeBottom(e) {\n            const sizes = this.view.getSizes();\n            this.view.addClass('drag');\n\n            s.e('input.pointer.setHandlers', {\n                move: e => {\n                    const height = e.clientY - sizes.y;\n                    this.view.setSize(null, height);\n                    this.recalcDimensions();\n                    s.e('appFrame.changeSize', { appFrame: this, height });\n                },\n                up: (e) => {\n                    s.e('input.pointer.setHandlers', { move: null, up: null });\n                    this.view.removeClass('drag');\n                }\n            });\n        },\n        resizeLeft(e) {\n            const sizes = this.view.getSizes();\n            const maxW = sizes.x + sizes.width;\n            this.view.addClass('drag');\n\n            s.e('input.pointer.setHandlers', {\n                move: e => {\n                    const width = maxW - e.clientX;\n                    this.view.setSize(width);\n                    this.view.setPosition(e.clientX);\n                    this.recalcDimensions();\n                    s.e('appFrame.changeSize', { appFrame: this, width });\n                    s.e('appFrame.changePosition', { appFrame: this, x: e.clientX });\n                },\n                up: (e) => {\n                    s.e('input.pointer.setHandlers', { move: null, up: null });\n                    this.view.removeClass('drag');\n                }\n            });\n        },\n        resizeRight(e) {\n            const sizes = this.view.getSizes();\n            this.view.addClass('drag');\n\n            s.e('input.pointer.setHandlers', {\n                move: e => {\n                    const width = e.clientX - sizes.x;\n                    this.view.setSize(width);\n                    this.recalcDimensions();\n                    s.e('appFrame.changeSize', { appFrame: this, width });\n                },\n                up: (e) => {\n                    s.e('input.pointer.setHandlers', { move: null, up: null });\n                    this.view.removeClass('drag');\n                }\n            });\n        },\n        resizeTopLeft(e) {\n            const sizes = this.view.getSizes();\n            const maxW = sizes.x + sizes.width;\n            const maxÐ = sizes.y + sizes.height;\n            this.view.addClass('drag');\n\n            s.e('input.pointer.setHandlers', {\n                move: e => {\n                    const height = maxÐ - e.clientY;\n                    const width = maxW - e.clientX;\n                    this.view.setSize(width, height);\n                    this.view.setPosition(e.clientX, e.clientY);\n                    this.recalcDimensions();\n\n                    s.e('appFrame.changeSize', { appFrame: this, width, height });\n                    s.e('appFrame.changePosition', { appFrame: this, x: e.clientX, y: e.clientY });\n                },\n                up: (e) => {\n                    s.e('input.pointer.setHandlers', { move: null, up: null });\n                    this.view.removeClass('drag');\n                }\n            });\n        },\n        resizeTopRight(e) {\n            const sizes = this.view.getSizes();\n            const maxÐ = sizes.y + sizes.height;\n            this.view.addClass('drag');\n\n            s.e('input.pointer.setHandlers', {\n                move: e => {\n                    const height = maxÐ - e.clientY;\n                    const width = e.clientX - sizes.x;\n                    this.view.setSize(width, height);\n                    this.view.setPosition(null, e.clientY);\n                    this.recalcDimensions();\n\n                    s.e('appFrame.changeSize', { appFrame: this, width, height });\n                    s.e('appFrame.changePosition', { appFrame: this, y: e.clientY });\n                },\n                up: (e) => {\n                    s.e('input.pointer.setHandlers', { move: null, up: null });\n                    this.view.removeClass('drag');\n                }\n            });\n        },\n        resizeBottomLeft(e) {\n            const sizes = this.view.getSizes();\n            const maxW = sizes.x + sizes.width;\n            this.view.addClass('drag');\n\n            s.e('input.pointer.setHandlers', {\n                move: e => {\n                    const width = maxW - e.clientX;\n                    const height = e.clientY - sizes.y;\n\n                    this.view.setSize(width, height);\n                    this.view.setPosition(e.clientX);\n                    this.recalcDimensions();\n                    s.e('appFrame.changeSize', { appFrame: this, width, height });\n                    s.e('appFrame.changePosition', { appFrame: this, x: e.clientX });\n                },\n                up: (e) => {\n                    s.e('input.pointer.setHandlers', { move: null, up: null });\n                    this.view.removeClass('drag');\n                }\n            });\n        },\n        resizeBottomRight(e) {\n            //const viewSizes = this.view.getSizes(); //sizes of nsBarTop\n            //const shift = { x: e.clientX - viewSizes.x, y: e.clientY - viewSizes.y };\n\n            const sizes = this.view.getSizes();\n            this.view.addClass('drag');\n\n            s.e('input.pointer.setHandlers', {\n                move: e => {\n                    const width = e.clientX - sizes.x;\n                    const height = e.clientY - sizes.y;\n                    this.view.setSize(width, height);\n                    this.recalcDimensions();\n                    s.e('appFrame.changeSize', { appFrame: this, width, height });\n                },\n                up: (e) => {\n                    s.e('input.pointer.setHandlers', { move: null, up: null });\n                    this.view.removeClass('drag');\n                }\n            });\n        },\n    }\n\n    return appFrameProto;\n}"}},"monacoEditor":{"js":"async () => {\n    return class MonacoEditor {\n\n        constructor(dataNode, v) {\n            this.dataNode = dataNode;\n            this.v = new v({ class:['monacoEditor']});\n            this.isEditorInitiated = false;\n        }\n\n        activate() {\n            this.show();\n\n            if (this.isEditorInitiated) return;\n            this.isEditorInitiated = true;\n\n            // this.editor = ace.edit(this.v.getDOM(), {mode: 'ace/mode/javascript', selectionStyle: 'text'});\n            // this.editor.setTheme('ace/theme/iplastic');\n            // this.editor.session.on('changeMode', (e, session) => {\n            //     if (\"ace/mode/javascript\" === session.getMode().$id) {\n            //         if (!!session.$worker) {\n            //             session.$worker.send(\"setOptions\", [{\"esversion\": 9, \"esnext\": false}]);\n            //         }\n            //     }\n            // });\n            // this.editor.session.setUseWorker(false);\n            // this.editor.session.setMode('ace/mode/javascript');\n            // this.editor.setValue(this.outlinerNode.getContextNode().getData(), 1);\n            //this.editor.destroy();\n\n            this.editor = monaco.editor.create(this.v.getDOM(), {\n                value: this.dataNode.getData(),\n                automaticLayout: true,\n                language: 'javascript', fontSize: '14px', theme: 'vs-light',\n            });\n            //this.editor.layout();\n            this.editor.getModel().onDidChangeContent(async e => {\n                const value = this.editor.getValue();\n                // try { eval(js); s.e('JsEvalResult', {error: 0}); }\n                // catch (e) { s.e('JsEvalResult', {error: e}); }\n\n                s.e('state.update', {dataNode: this.dataNode, data: value});\n            });\n        }\n        deactivate() {\n            this.hide();\n        }\n\n        getV() { return this.v; }\n        show() { this.v.show(); }\n        hide() { this.v.hide(); }\n        close() { this.v.removeFromDom(); }\n    }\n}","gender":"okok"},"txtEditor":{"js":"async () => {\n    return class TxtEditor {\n\n        constructor(dataNode, v, vContainer) {\n\n            this.dataNode = dataNode;\n            this.v = new v({style: {height: '100%'}});\n            this.v.attachShadow();\n\n            const css = new v({tagName: 'style'});\n            css.setHtml(`\ntextarea {\n    font-family: 'Roboto', sans-serif;\n    width: 99%;\n    height: 99%;\n    padding: 0;\n    border: 0;\n    outline: 0;\n`);\n            this.v.insert(css.getDOM());\n\n            this.textArea = new v({ tagName: 'textarea', value: dataNode.getData()});\n            this.textArea.on('keyup', e => {\n                const newVal = e.target.value;\n                if (dataNode.getData() === newVal) return;\n                s.e('state.update', {dataNode: this.dataNode, data: newVal});\n            });\n            this.v.insert(this.textArea.getDOM());\n            //e('>', [this.textArea, this.v]);\n        }\n        activate() {\n            this.v.show();\n            const parent = this.v.parent();\n        }\n        deactivate() { this.v.hide(); }\n        getV() { return this.v; }\n        close() { this.v.removeFromDom(); }\n    }\n}"},"dataBrowser":{"js":"async () => {\n    return class dataBrowser {\n\n        getV() { return this.v; }\n        getTitle() { return 'Data browser'; }\n        async init() {\n            this.http = new (await s.f('sys.httpClient'));\n            this.nodes = new Map;\n\n            const v = await s.f('sys.ui.view');\n            this.v = new v({ class: 'dataBrowser' });\n\n            const DataNode = await s.f('sys.apps.GUI.dataNode');\n            this.node = DataNode;\n            const DataBrowserNode = await s.f('sys.apps.dataBrowser.node');\n            this.outlinerNode = DataBrowserNode;\n\n            const dataNode = new DataNode(s);\n            const node = new DataBrowserNode;\n            await node.init(dataNode, true, this);\n            node.removeSubNodesShift();\n            e('>', [node, this.v]);\n\n            this.openedPaths = s.e('localState.get', 'openedPaths');\n            if (this.openedPaths) {\n                this.openedPaths = JSON.parse(this.openedPaths);\n            } else {\n                this.openedPaths = {};\n            }\n\n            //todo clear this.openedPaths which not exists in \"s\"\n            this.addNode(node);\n            await node.open(this.openedPaths);\n\n            this.buffer = null;\n        }\n        addNode(dataBrowserNode) {\n            this.nodes.set(dataBrowserNode.getId(), dataBrowserNode);\n        }\n        removeNode(id) {\n            this.nodes.delete(id);\n        }\n        //deactivate() { this.v.hide(); }\n        close() { }\n        //isEmpty() { return this.outLinerRootNode.isEmpty()}\n        getOutlinerNodeById(id) { return this.nodes.get(id); }\n\n        async duplicate(outlinerNode) {\n\n            const parentDataNode = outlinerNode.getParent().getDataNode();\n            const dataNode = outlinerNode.getDataNode();\n            const newK = dataNode.getKey() + '_copy';\n\n            if (parentDataNode.get(newK)) {\n                console.log(`Key ${newK} already exists in object.`); return;\n            }\n            let v = dataNode.getData();\n            if (s.f('sys.isObject', v) || s.f('sys.isArray', v)) v = structuredClone(v);\n\n            const newDataNode = new this.node(v);\n            newDataNode.setKey(newK);\n            const newOutlinerNode = new this.outlinerNode;\n            await newOutlinerNode.init(newDataNode, false, this);\n\n            e('>after', [newOutlinerNode.getV(), outlinerNode.getV()]);\n            this.nodes.set(newOutlinerNode.getDomId(), newOutlinerNode);\n\n            parentDataNode.set(newK, v);\n            setTimeout(() => newOutlinerNode.focus(), 100);\n\n            newDataNode.setPath(newOutlinerNode.getPath());\n            s.e('state.update', { dataNode: newDataNode, data: v });\n        }\n\n        async handleKeydown(e) {\n\n            return;\n\n            if (!e.target.classList.contains('dataKey')) return;\n\n\n            const outlinerNode = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n            if (!outlinerNode) { console.log('outlinerNode not found'); return; }\n\n            const k = e.key;\n            const ctrl = e.ctrlKey || e.metaKey;\n\n            if (k === 'Enter') {\n                e.preventDefault();\n            } else if (k === 'Tab') {\n                e.preventDefault();\n                //todo reimplement later\n                // if (e.shiftKey) {\n                //     const parent = outlinerNode.getParent();\n                //     window.e('>after', [outlinerNode.getV(), parent.getV()]);\n                // } else if (outlinerNode.prev()) {\n                //     window.e('>', [outlinerNode.getV(), outlinerNode.prev().getNodesV()]);\n                // }\n\n            } /*else if (ctrl && k === 'ArrowUp' && outlinerNode.prev()) {\n                window.e('>after', [outlinerNode.prev().getV(), outlinerNode.getV()]);\n            } else if (ctrl && k === 'ArrowDown' && outlinerNode.next()) {\n                window.e('>after', [outlinerNode.getV(), outlinerNode.next().getV()]);\n            } */else {\n                return;\n            }\n            e.target.focus();\n            //await this.save();\n        }\n\n        async handleKeyup(e) {\n\n            if (!e.target.classList.contains('dataKey')) return;\n\n            const ignoreKeys = ['Enter', 'Tab', 'Control', 'Meta', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];\n            if (new Set(ignoreKeys).has(e.key)) return;\n\n            const outlinerNode = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n\n            const dataNode = outlinerNode.getDataNode();\n            const newK = e.target.innerText;\n            const v = dataNode.getData();\n\n            if (newK.length === 0) {\n                if (!confirm('Delete object?')) return;\n                s.e('state.del', { outlinerNode })\n                return;\n            }\n\n            const oldPath = outlinerNode.getPath();\n            const newPath = oldPath.length === 1 ? [newK] : [...oldPath.slice(0, -1), newK];\n\n            if (newPath.toString() === oldPath.toString()) return;\n\n            await this.http.post('/stateUpdate', { cmds: [{ newPath: newPath, oldPath: oldPath, op: 'mv' }] });\n            const parentDataNode = outlinerNode.getParent().getDataNode();\n\n            parentDataNode.set(newPath.at(-1), v);\n            parentDataNode.del(oldPath.at(-1));\n\n            dataNode.setKey(newK);\n        }\n\n        async handleClick(e) {\n\n            const addOpenedNode = node => {\n                //todo some func to direct iteration in depth of object by path\n                let lastObj = this.openedPaths;\n                const path = node.getPath();\n\n                for (let i = 0; i < path.length; i++) {\n                    const part = path[i];\n                    if (!lastObj[part]) lastObj[part] = {};\n                    lastObj = lastObj[part];\n                }\n                s.e('localState.set', ['openedPaths', JSON.stringify(this.openedPaths)]);\n            }\n            const deleteOpenedNode = node => {\n\n                let lastObj = this.openedPaths;\n                let lastPart;\n                const path = node.getPath();\n\n                for (let i = 0; i < path.length; i++) {\n                    const part = path[i];\n                    const isLastIndex = i === path.length - 1;\n                    if (isLastIndex) {\n                        delete lastObj[part];\n                        break;\n                    }\n                    lastObj = lastObj[part];\n                    lastPart = part;\n                }\n                s.e('localState.set', ['openedPaths', JSON.stringify(this.openedPaths)]);\n            }\n            const classList = e.target.classList;\n\n            if (classList.contains('openClose') || classList.contains('openCloseArrow')) {\n\n                let outlinerNode = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n                if (!outlinerNode.hasSomethingToOpen()) {\n                    return;\n                }\n                if (outlinerNode.isOpened) {\n                    outlinerNode.close()\n                    deleteOpenedNode(outlinerNode);\n                } else {\n                    outlinerNode.open();\n                    addOpenedNode(outlinerNode);\n                }\n                return;\n            }\n\n            if (classList.contains('dataKey')) {\n\n                let node = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n                if (!node.hasSomethingToOpen()) return;\n                if (!node.isOpened) {\n                    node.open();\n                    addOpenedNode(node);\n                }\n            }\n        }\n        handleContextmenu(e) {\n            e.preventDefault();\n\n            const isDataK = e.target.classList.contains('dataKey');\n            const isDataV = e.target.classList.contains('dataValue');\n            if (!isDataK && !isDataV) return;\n\n            const node = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n            const dataNode = node.getDataNode();\n            const data = dataNode.getData();\n\n            const v = s.f('sys.ui.view');\n            const createBtn = (txt) => {\n                return new v({ txt, class: ['btn', 'contextMenu', 'white', 'hoverGray'] });\n            }\n\n            const popup = s.sys.popup;\n            let submenu;\n            const removeSubmenu = () => {\n                if (!submenu) return;\n                submenu.clear();\n                submenu = null;\n            }\n\n            let oBtn = createBtn('Open with');\n            let openWithBtn = oBtn;\n            oBtn.on('pointerenter', async () => {\n                removeSubmenu();\n                submenu = new (s.f('sys.apps.GUI.popup'));\n                window.e('app.addViewElement', submenu);\n\n                const apps = s.sys.apps;\n                //todo const authorizedUserApps = s.users[user].apps;\n\n                for (let name in apps) {\n                    if (name === 'GUI') continue;\n                    let appBtn = createBtn(name);\n                    appBtn.on('click', () => {\n                        window.e('openNode', { appPath: `sys.apps.${name}`, outlinerNode: node });\n                        popup.clear();\n                    });\n                    window.e('>', [appBtn, submenu]);\n                }\n                submenu.putRightTo(openWithBtn);\n            });\n            window.e('>', [oBtn, popup]);\n\n\n            if (typeof data === 'object' && data !== null) {\n                oBtn = createBtn('Add item');\n                oBtn.on('pointerenter', removeSubmenu);\n                oBtn.on('click', () => {\n\n                    if (Array.isArray(data)) {\n                        data.push('item' + data.length + 1);\n                    } else {\n                        let c = 0;\n                        while (1) {\n                            c++;\n                            const k = 'newKey' + c; const v = 'newValue';\n                            if (data[k]) continue;\n\n                            data[k] = v;\n                            const dataNode = new this.node;\n                            dataNode.setPath([...node.getPath(), k]);\n                            s.e('state.update', { dataNode, data: v });\n                            break;\n                        }\n                    }\n\n                    node.reopen();\n                    popup.clear();\n                });\n                window.e('>', [oBtn, popup]);\n            }\n\n            oBtn = createBtn('Copy');\n            oBtn.on('click', () => {\n                this.buffer = { mode: 'copy', node };\n                popup.clear();\n            });\n            oBtn.on('pointerenter', removeSubmenu);\n            window.e('>', [oBtn, popup]);\n\n            oBtn = createBtn('Cut');\n            oBtn.on('click', () => {\n                this.buffer = { mode: 'cut', node };\n                popup.clear();\n            });\n            oBtn.on('pointerenter', removeSubmenu);\n            window.e('>', [oBtn, popup]);\n\n            if (this.buffer) {\n                oBtn = createBtn('Paste');\n                oBtn.on('click', async () => {\n                    if (!this.buffer) return;\n\n                    const contextNodeData = node.getDataNode().getData();\n                    if (!s.f('sys.isObject', contextNodeData) && !Array.isArray(contextNodeData)) return;\n\n                    const bufOurlinerNode = this.buffer.outlinerNode;\n                    const dataPath = bufOurlinerNode.getPath();\n\n                    const dataNodeCopy = new this.node;\n                    //todo in case of array we don't need to set key. just push to array\n                    dataNodeCopy.setPath([...node.getPath(), dataPath.at(-1)]);\n\n                    const data = structuredClone(bufOurlinerNode.getDataNode().getData());\n                    s.e('state.update', { dataNode: dataNodeCopy, data });\n                    if (this.buffer.mode === 'cut') {\n                        await s.e('state.del', { outlinerNode: bufOurlinerNode });\n                    }\n\n                    this.buffer = null;\n                    node.reopen(); //todo remember opened nodes\n                    popup.clear();\n                });\n                oBtn.on('pointerenter', removeSubmenu);\n                window.e('>', [oBtn, popup]);\n            }\n\n            oBtn = createBtn('Duplicate');\n            oBtn.on('click', async () => {\n                await this.duplicate(node);\n                popup.clear();\n            });\n            oBtn.on('pointerenter', removeSubmenu);\n            window.e('>', [oBtn, popup]);\n\n            oBtn = createBtn('Console log');\n            oBtn.on('pointerenter', removeSubmenu);\n            oBtn.on('click', () => {\n                s.l(dataNode);\n                popup.clear();\n            });\n            window.e('>', [oBtn, popup]);\n\n            oBtn = createBtn('Console path');\n            oBtn.on('pointerenter', removeSubmenu);\n            oBtn.on('click', () => {\n                s.l(node.getPath());\n                popup.clear();\n            });\n            window.e('>', [oBtn, popup]);\n\n            oBtn = createBtn('Convert type to');\n            let convertTypeBtn = oBtn;\n            oBtn.on('pointerenter', () => {\n                removeSubmenu();\n                submenu = new (s.f('sys.apps.GUI.popup'));\n                window.e('app.addViewElement', submenu);\n\n                const types = ['Bool', 'String', 'Object', 'Array'];\n                types.forEach(t => {\n                    let btn = createBtn(t);\n                    btn.on('click', () => {\n                        let data;\n                        if (t === 'Array') data = [];\n                        else if (t === 'Bool') {\n                            data = dataNode.getData() === 'false' ? false : true;\n                        }\n                        else if (t === 'Object') data = {};\n                        else if (t === 'String') data = 'str';\n                        else if (data === undefined) return;\n                        s.e('state.update', { outlinerNode: node, data });\n\n                        node.getParent().reopen();\n                        popup.clear();\n                    });\n                    window.e('>', [btn, submenu]);\n                });\n                submenu.putRightTo(convertTypeBtn);\n\n            });\n            window.e('>', [oBtn, popup]);\n\n            popup.onClear(() => removeSubmenu());\n            popup.putRightToPointer({ x: e.clientX, y: e.clientY });\n        }\n\n    }\n}","node":{"js":"async () => {\n\n    return class dataBrowserNode {\n\n        async init(dataNode, isRoot, dataBrowser) {\n            this.dataNode = dataNode;\n            this.dataBrowser = dataBrowser;\n            this.domId = s.f('sys.uuid');\n\n            const v = await s.f('sys.ui.view');\n            this.v = new v({ id: this.domId, class: ['node'] });\n            this.isOpened = false;\n            this.isRoot = isRoot;\n\n            if (!this.isRoot) await this.createDataFields(dataNode);\n\n            this.subNodesV = new v({ class: ['subNodes', 'shift'] });\n            e('>', [this.subNodesV, this.v]);\n        }\n        getId() { return this.domId; }\n\n        //todo render undedined and null fields\n        async createDataFields(dataNode) {\n            const data = dataNode.getData();\n            let dType = dataNode.getDataType();\n            let dTypeLabel = { boolean: 'bool', function: 'f', number: 'num', object: '' }[dType] ?? dType;\n            if (data === null) dTypeLabel = 'null';\n            else if (data === undefined) dTypeLabel = 'undefined';\n\n            const v = await s.f('sys.ui.view');\n            const container = new v({ class: ['nodeContainer', 'flex'] }); e('>', [container, this.v]);\n\n            this.openClose = new v({ class: 'openClose' });\n            this.openClose.setAttr('outliner_node_id', this.domId);\n            e('>', [this.openClose, container]);\n\n            const openCloseArrow = new v({ class: 'openCloseArrow' });\n            openCloseArrow.setAttr('outliner_node_id', this.domId);\n            e('>', [openCloseArrow, this.openClose]);\n            if (!this.hasSomethingToOpen()) this.openCloseBtnHide();\n\n            this.keyV = new v({ class: 'dataKey', txt: dataNode.getKey() });\n            this.keyV.setAttr('outliner_node_id', this.domId);\n            this.keyV.toggleEdit();\n            e('>', [this.keyV, container]);\n\n            if (!s.f('sys.isObject', data) && !Array.isArray(data)) {\n                e('>', [new v({ class: 'sep', txt: ':', style: { marginRight: '5px' } }), container]);\n            }\n\n            let slicedStrInfo;\n            let opsBtn;\n            const createValueV = (txt, className, color) => {\n                if (txt === false) txt = 'false';\n\n                return new v({ txt, class: className, style: { color: color } }); //whiteSpace: 'nowrap'\n            }\n\n            let valueV;\n\n            if (dType === 'boolean') {\n                valueV = createValueV(data, 'dataValue', 'blue');\n                valueV.iEditMod();\n            } else if (dType === 'number') {\n                valueV = createValueV(data, 'dataValue', '#221199');\n                valueV.iEditMod();\n            } else if (dType === 'string') {\n\n                const limit = 500;\n                let isSliced = false;\n                let str = data;\n                if (str.length > limit) {\n                    str = str.slice(0, limit).trim() + '...';\n                    str = str.replaceAll('\\n', '');\n                    isSliced = true;\n                }\n                valueV = createValueV(str, ['dataValue', 'string'], '#AA1011');\n                if (isSliced) {\n                    slicedStrInfo = new v({ txt: 'and more ' + (data.length - limit) + ' chars', style: { marginLeft: '5px', 'white-space': 'nowrap' } });\n                } else {\n                    valueV.iEditMod();\n                }\n\n            } else {\n                valueV = createValueV(dTypeLabel, 'dataType', 'gray')\n            }\n            valueV.setAttr('outliner_node_id', this.domId);\n            valueV.on('keyup', async () => this.netUpdate());\n\n\n            if (dType === 'string') e('>', [new v({ class: 'quote', txt: \"'\" }), container]);\n            e('>', [valueV, container]);\n            if (dType === 'string') e('>', [new v({ class: 'quote', txt: \"'\" }), container]);\n\n            if (slicedStrInfo) e('>', [slicedStrInfo, container]);\n            if (opsBtn) e('>', [opsBtn, container]);\n\n            this.valueV = valueV;\n        }\n\n        async netUpdate() {\n            const v = this.valueV.getTxt();\n            if (!v.trim()) {\n                if (confirm('Delete prop?')) {\n                    s.e('state.del', { outlinerNode: this });\n                }\n                return;\n            }\n            if (v === this.getDataNode().getData()) return;\n\n            s.e('state.update', { outlinerNode: this, data: v });\n        }\n        getDomId() { return this.domId }\n\n        async requestData() {\n\n            const path = this.getPath();\n            const http = new (await s.f('sys.httpClient'));\n            const { data } = await http.post('/state', { path });\n            if (data) {\n                this.dataNode.setData(data);\n\n                //todo add method, getParentNode\n                const parentNode = s.find(path.slice(0, -1));\n                if (parentNode) {\n                    parentNode[path[path.length - 1]] = data;\n                }\n            } else {\n                //this.dataNode.getData()[s.sys.sym.IS_EMPTY] = true;\n            }\n        }\n\n        async open(openedPaths = {}) {\n\n            const dType = this.dataNode.getDataType();\n            let v = this.dataNode.getData();\n            if (dType !== 'object' || v === null) return;\n\n            if (s.f('sys.isEmptyObject', v) || (Array.isArray(v) && v.length === 0)) {\n\n                if (!v[s.sys.sym.IS_EMPTY]) await this.requestData();\n            }\n\n            v = this.dataNode.getData();\n\n            const NodeClass = await s.f('sys.apps.GUI.dataNode');\n            const OutlinerNodeClass = await s.f('sys.apps.dataBrowser.node');\n\n            const renderNode = async (k, node) => {\n                const dataNode = new NodeClass(node);\n                dataNode.setKey(k);\n\n                const outlinerNode = new OutlinerNodeClass;\n                await outlinerNode.init(dataNode, false, this.dataBrowser);\n                e('>', [outlinerNode.getV(), this.getNodesV()]);\n                this.dataBrowser.addNode(outlinerNode);\n\n                if (openedPaths[k] && outlinerNode.hasSomethingToOpen()) {\n                    await outlinerNode.open(openedPaths[k]);\n                }\n            }\n\n            if (Array.isArray(v)) {\n                for (let i = 0; i < v.length; i++) await renderNode(i, v[i]);\n            } else {\n                const nameNode = {};\n                for (let k in v) {\n                    const kLower = k.toLowerCase();\n                    if (!nameNode[kLower]) nameNode[kLower] = [];\n                    nameNode[kLower].push({ k, node: v[k] });\n                }\n                const sortedKeys = Object.keys(nameNode).sort();\n\n                for (let i = 0; i < sortedKeys.length; i++) {\n\n                    const nodes = nameNode[sortedKeys[i]];\n                    for (let j = 0; j < nodes.length; j++) {\n                        await renderNode(nodes[j].k, nodes[j].node);\n                    }\n                }\n            }\n            this.isOpened = true;\n            if (this.openClose) this.openClose.addClass('opened');\n        }\n        async close() {\n            const nodesV = this.getNodesV();\n            const children = nodesV.getChildren();\n            //todo should be recursive\n            for (let i = 0; i < children.length; i++) {\n                const id = children[i].id;\n                if (!id) throw Error('no outliner_node_id on ' + children[i]);\n                this.dataBrowser.removeNode(id);\n            }\n            nodesV.clear();\n            this.isOpened = false;\n            if (!this.isRoot) {\n                this.openClose.removeClass('opened');\n            }\n        }\n\n        reopen() {\n            //todo close all items recursive and open again\n            if (this.isOpened) this.close();\n            this.open();\n        }\n\n        hasSomethingToOpen() {\n            const data = this.getDataNode().getData();\n            const dType = this.getDataNode().getDataType();\n\n            if (dType !== 'object' || data === null) return false;\n\n            return true;\n            //if (Array.isArray(data)) return data.length > 0;\n            //return !s.f('sys.isEmptyObject', data);\n        }\n\n        async showOutlinerOpsPopup(opsBtn) {\n            s.popup.clear();\n\n            const v = await s.f('sys.ui.view');\n\n            const createBtn = txt => new v({ txt, class: 'btn' });\n\n            let oBtn = createBtn('Add');\n            oBtn.on('click', async () => {\n                this.getDataNode().set('newProp', 'value');\n                this.openClose.visibilityShow();\n                await this.close();\n                await this.open();\n                s.popup.clear();\n            });\n            e('>', [oBtn, s.popup]);\n\n            // oBtn = createBtn('delete'); oBtn.on('click', e => {\n            //     if (confirm('Delete prop?')) {\n            //         s.e('state.del', {outlinerNode: this});\n            //     }\n            //     s.popup.clear();\n            // });\n            // e('>', [oBtn, s.popup]);\n\n            // oBtn = createBtn('console.log'); oBtn.on('click', e => {\n            //     console.log(this.getDataNode());\n            //     s.popup.clear();\n            // });\n            e('>', [oBtn, s.popup]);\n\n            s.popup.putRightTo(opsBtn);\n        }\n        openCloseBtnShow() { this.openClose.visibilityShow(); }\n        openCloseBtnHide() { this.openClose.visibilityHide(); }\n\n        //isEmpty() { return !this.dataNodesV.getDOM().children.length }\n        isInRoot() { return this.getParent().isRoot }\n        getParent() {\n            const node = this.dataBrowser.nodes.get(this.v.parentDOM().parentNode.id);\n            if (!node) {\n                // s.l(id, this.outliner.nodes);\n            }\n            return node;\n        }\n        getPath() {\n            let path = [];\n            let lastNode = this;\n            while (!lastNode.isRoot) {\n                path.push(lastNode.getDataNode().getKey());\n                lastNode = lastNode.getParent();\n            }\n            return path.reverse();\n        }\n\n        // next() {\n        //     const next = this.v.getDOM().nextSibling;\n        //     return next ? s.outlinerPool.get(next.id) : null;\n        // }\n        // prev() {\n        //     const previous = this.v.getDOM().previousSibling;\n        //     return previous ? s.outlinerPool.get(previous.id) : null;\n        // }\n        getDataNode() { return this.dataNode }\n\n        getV() { return this.v }\n        getKeyValue() { return this.keyV.getTxt(); }\n\n        getNodesV() { return this.subNodesV }\n        removeSubNodesShift() { this.subNodesV.removeClass('shift'); }\n        focus() { this.keyV.focus(); }\n        remove() { this.getV().removeFromDom(); }\n    }\n}"}},"terminal":{"js":"() => {\n    return class terminal {\n\n        getV() { return this.v }\n        getTitle() { return 'Terminal'; }\n        init() {\n            const v = s.f('sys.ui.view');\n\n            this.v = new v({ class: 'terminal' });\n            this.header = new v({ class: 'consoleHeader' });\n            e('>', [this.header, this.v]);\n\n            const clear = new v({ txt: 'clear', class: ['btn', 'cursorPointer'] });\n            clear.on('click', e => this.content.clear());\n            e('>', [clear, this.header]);\n\n            const scrollBlock = new v({ class: ['scrollBlock', 'flex'] });\n            e('>', [scrollBlock, this.header]);\n\n            //add persistence chain for every attribute like checked and etc\n            this.automaticScroll = new v({ tagName: 'input' });\n            this.automaticScroll.setAttr('name', 'automaticScroll');\n            this.automaticScroll.setAttr('type', 'checkbox');\n            this.automaticScroll.setAttr('checked', 'true');\n\n            e('>', [this.automaticScroll, scrollBlock]);\n            e('>', [new v({ txt: 'automatic scroll' }), scrollBlock]);\n\n            const consoleCmd = new v({ tagName: 'input', class: ['nooutline', 'consoleCmd'] });\n            this.consoleCmd = consoleCmd;\n            consoleCmd.setAttr('placeholder', 'cmd');\n            consoleCmd.setAttr('name', 'cmdInput');\n            consoleCmd.on('keydown', (e) => {\n                if (e.key !== 'Enter') return;\n                const v = e.target.value;\n\n                //autocomplete for commands\n                if (v === 'outliner.hide') {\n                    //localState.set('outlinerHidden', 1);\n                    //outliner hide\n                }\n                if (v === 'outliner.show') {\n                    //localState.del('outlinerHidden');\n                }\n            });\n            consoleCmd.on('keyup', e => { });\n            e('>', [consoleCmd, this.header]);\n\n            this.content = new v({ class: 'log' });\n            e('>', [this.content, this.v]);\n\n            e['terminal.logMsg'] = logMsg => {\n                const prev = new v({ tagName: 'pre', txt: logMsg });\n                e('>', [prev, this.content]);\n\n                if (this.automaticScroll.isChecked()) {\n                    this.v.scrollDown();\n                }\n            }\n        }\n        enableAutomaticScroll() { this.automaticScroll.setAttr('checked', ''); }\n    }\n\n}"},"auth":{"js":"() => {\n    return class auth {\n\n        getDefaultSize() {\n            return { width: 350, height: 136 }\n        }\n        getV() { return this.v }\n        getTitle() { return 'Auth'; }\n        async init() {\n\n            if (this.v) this.v.clear();\n\n            const v = await s.f('sys.ui.view');\n            const http = new (await s.f('sys.httpClient'));\n\n            let authPanel = new v({ class: ['authApp'] });\n            if (this.v) authPanel = this.v;\n            else {\n                this.v = authPanel;\n            }\n\n            const container = new v;\n            e('>', [container, authPanel]);\n\n            const username = (await http.get('/sign/user'))?.data?.user?.username;\n\n            if (username) {\n                const sign = new v({ tagName: 'span', txt: `Logged in as: [${username}]`, });\n                e('>', [sign, authPanel]);\n\n                const signOut = new v({ txt: 'Sign Out', class: ['btn', 'inlineBlock', 'cursorPointer'] });\n                signOut.on('click', async (e) => {\n                    e.stopPropagation();\n                    await http.post('/sign/out');\n                    await this.init();\n                });\n                signOut.on('contextmenu', e => e.stopPropagation());\n                e('>', [signOut, authPanel]);\n            } else {\n\n                const usernameInput = new v({ tagName: 'input' });\n                usernameInput.setAttr('placeholder', 'username');\n                usernameInput.on('pointerdown', e => {\n                    e.stopPropagation();\n                });\n                e('>', [usernameInput, container]);\n\n                e('>', [new v({ tagName: 'br' }), container]);\n\n                const passwordInput = new v({ tagName: 'input' });\n                passwordInput.setAttr('placeholder', 'password');\n                passwordInput.setAttr('type', 'password');\n                passwordInput.on('pointerdown', e => {\n                    e.stopPropagation();\n                });\n                e('>', [passwordInput, container]);\n\n                e('>', [new v({ tagName: 'br' }), container]);\n                e('>', [new v({ tagName: 'br' }), container]);\n\n                const signIn = new v({ txt: 'Sign In', class: ['btn', 'inlineBlock', 'cursorPointer'] });\n                signIn.on('click', async e => {\n                    e.stopPropagation();\n\n                    const username = usernameInput.getVal().trim(); if (!username) return;\n                    const password = passwordInput.getVal().trim(); if (!password) return;\n\n                    const { data } = await http.post('/sign/in', { username, password });\n                    if (data === 'ok') {\n                        await this.init();\n                    }\n                });\n                signIn.on('contextmenu', e => e.stopPropagation());\n                e('>', [signIn, container]);\n            }\n        }\n    }\n}"},"fileUploader":{"js":"() => {\n    return class fileUploader {\n\n        getV() { return this.v }\n        getTitle() { return 'File uploader'; }\n        async init() {\n\n            if (this.v) this.v.clear();\n\n            const v = await s.f('sys.ui.view');\n            const http = new (await s.f('sys.httpClient'));\n            let authPanel = new v;\n            if (this.v) authPanel = this.v;\n            else {\n                this.v = authPanel;\n            }\n            const tokenInput = new v({ tagName: 'input', txt: 'clear', class: ['tokenInput'] });\n            tokenInput.setAttr('placeholder', 'File upload');\n            tokenInput.setAttr('type', 'password');\n            tokenInput.on('pointerdown', e => {\n                e.stopPropagation();\n            });\n            e('>', [tokenInput, authPanel]);\n        }\n    }\n}"}},"fs":{"js":"async () => {\n    const promise = (await import(\"node:fs\")).promises;\n    const {createReadStream, createWriteStream} = (await import(\"node:fs\"));\n\n    return class FS {\n    \n        //readFileNative = util.promisify(fs.readFile);\n        //writeFileNative = util.promisify(fs.writeFile);\n        // renameNative = util.promisify(fs.rename);\n        // mkdir = util.promisify(fs.mkdir);\n        // open = util.promisify(fs.open);\n        // close = util.promisify(fs.close);\n        constructor(logger) { this.logger = logger; }\n\n        async openFile(path, flags) { return await promise.open(path, flags); }\n        async closeFile(fd) { return await promise.close(fd); }\n        async readFile(path, encoding) { return await promise.readFile(path, encoding === undefined ? 'utf8' : encoding) }\n        async writeFile(path, data) { return await promise.writeFile(path, data) }\n        async rm(path) { return await promise.rm(path) }\n        async stat(path) { return await promise.stat(path) }\n\n        async watch(path) {\n            const p = (await import(\"node:fs\")).promises;\n            return p.watch(path);\n        }\n        async createReadStream(path, options) { return createReadStream(path, options); } //using old api because promise.createReadStream cause warnings\n        async createWriteStream(path, options) { return createWriteStream(path, options); }\n\n        async writeFileIfNotExistsCreate(path, data) {}\n        async readFileIfNotExistsCreate(path, defaultValue = '') {\n            if (!await this.exists(path)) {\n                await this.writeFile(path, defaultValue);\n                return defaultValue;\n            }\n            return await this.readFile(path);\n        }\n        async mv(oldPath, newPath) { return await this.renameNative(oldPath, newPath); }\n    \n        async readJSONIfNotExistsCreate(path) {\n            if (!this.exists(path)) {\n                await this.writeFile(path, '{}');\n                return {};\n            }\n            return JSON.parse(await this.readFile(path, 'utf8'));\n        }\n    \n        async exists(path) {\n            try {\n                await promise.access(path);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n\n        async mkDirIfNotExists(path) {\n            if (!await this.exists(path)) await promise.mkdir(path, {recursive: true});\n        }\n        async mkDir(path) { return await this.mkdir(path); }\n        async readDir(path) {\n            return new Promise((resolve) => {\n                fs.readdir(path, (err, files) => resolve(files));\n            });\n        }\n        rmSync(path) { fs.rmSync(path); }\n\n        extract() {\n            console.log(s.decompress);\n        }\n    }\n}"},"fsChangesSlicer":{"js":"async path => {\n    return {\n        isStarted: false,\n        ac: new AbortController,\n        start: async function () {\n            if (this.isStarted) return;\n            this.generator = await s.nodeFS.watch(path, {signal: this.ac.signal});\n            for await (const e of this.generator) if (this.slicer) await this.slicer(e);\n            s.l('s.fsChangesSlicer STARTED');\n            this.isStarted = true;\n        },\n        stop: function () { this.ac.abort(); }\n    }\n}"},"getTimestamp":{"js":"() => {\n        const dt = new Date;\n        let year = dt.getFullYear().toString().padStart(4, '0');\n        let day = dt.getDate().toString().padStart(2, '0');\n        let month = (dt.getMonth()+1).toString().padStart(2, '0')\n\n        return `${year}-${month}-${day} ${\n            dt.getHours().toString().padStart(2, '0')}:${\n            dt.getMinutes().toString().padStart(2, '0')}:${\n            dt.getSeconds().toString().padStart(2, '0')}`;\n    }"},"getTimeStr":{"js":"(milliseconds) => {\nconst d = new Date(null); d.setMilliseconds(milliseconds);\nreturn d.toISOString().slice(11, -1);\n}"},"httpClient":{"js":"() => {\n    return class HttpClient {\n\n        constructor(baseURL = '', headers = {}, options = {}) {\n\n            this.headers = headers;\n            if (!this.headers['Content-Type']) {\n                this.headers['Content-Type'] = 'application/json';\n            }\n            if (baseURL) this.baseURL = baseURL;\n        }\n\n        async rq(method, url, params, headers, options = {}) {\n            let timeoutId;\n            const controller = new AbortController(); if (options.timeout) timeoutId = setTimeout(() => controller.abort(), options.timeout);\n            if (!headers['Content-Type']) headers['Content-Type'] = 'application/json';\n\n            const fetchParams = {method, headers, signal: controller.signal};\n\n            if (method === 'POST') {\n                if (params instanceof ArrayBuffer) {\n                    fetchParams.body = params;\n                } else {\n                    fetchParams.body = headers['Content-Type'] === 'application/json' ? JSON.stringify(params) : this.strParams(params);\n                }\n            } else {\n                if (Object.keys(params).length) url += '?' + new URLSearchParams(params);\n            }\n\n            const response = await fetch(this.baseURL ? this.baseURL + url : url, fetchParams);\n            if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }\n\n            let res = { statusCode: response.status, headers: response.headers };\n            if (options.blob) res.data = await response.blob();\n            else {\n                const contentType = response.headers.get('content-type') ?? '';\n                res.data = contentType.startsWith('application/json') ? await response.json() : await response.text();\n            }\n            return res;\n        }\n\n        async get(url, params = {}, headers = {}, options = {}) { return await this.rq('GET', url, params, headers, options); }\n        async post(url, params = {}, headers = {}, options = {}) { return await this.rq('POST', url, params, headers, options); }\n        async postBuf(url, buffer, query, headers = {}) {\n            if (query) url += '?' + new URLSearchParams(query);\n            headers['Content-Type'] = 'application/octet-stream';\n\n            return await this.rq('POST', url, buffer, headers);\n        }\n        async delete(url, params = {}, headers = {}, options = {}) { return await this.rq('DELETE', url, params, headers, options); }\n        strParams(params) {\n            let str = '';\n            for (let k in params) str = str + k + '=' + params[k] + '&';\n            return str.length ? str.slice(0, -1) : '';\n        }\n        async getFile(url, fName) {\n            const fs = new (await s.f('9f0e6908-4f44-49d1-8c8e-10e1b0128858'));\n            const r = await fetch(url);\n            await fs.writeFile(fName, Buffer.from(await r.arrayBuffer()));\n        }\n    }\n\n}"},"isArray":{"js":"d => Array.isArray(d)"},"isObject":{"js":"d => typeof d === 'object' && !Array.isArray(d) && d !== null"},"isUUID":{"js":"str => str.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}/)"},"list":{"js":"async () => {\n    return class List {\n\n        list = [];\n\n        add(item, index = null) {\n\n            if (index !== null) {\n                if (typeof index !== 'number') throw Error(`Index type is [${typeof index}].`);\n                this.list.splice(index, 0, item);\n\n                return index;\n            }\n\n            this.list.push(item);\n\n            return this.getLength() - 1;\n        }\n        del(index) { this.list.splice(index, 1) };\n        delLast() { this.list.pop(); };\n        pop() { return this.list.pop() }\n        get(index) { return this.list[index]; }\n        getAll() { return this.list; }\n        getFirst() { return this.list[0]; }\n        getLast() { return this.list[this.getLastIndex()] }\n        getLastIndex() { return this.list.length - 1; }\n        getLength() { return this.list.length; }\n        isEmpty() { return this.getLength() === 0; }\n        iterate(f) {\n            for (let i = 0; i < this.list.length; i++) f(this.list[i], i);\n        }\n        reset() { this.list = []; }\n    }\n    \n}"},"os":{"js":"async () => {\n\n    const {spawn, exec} = (await import('node:child_process'));\n\n    return class OS {\n        constructor(logger) {\n            this.logger = logger;\n            this.proc = null;\n        }\n        async run(cmd, detached, shell, procCallback, closeCallback) {\n\n            let args = cmd.split(' ');\n            let firstArg = args.shift();\n\n            const p = spawn(firstArg, args, {shell, detached});\n            this.proc = p;\n            if (procCallback) await procCallback(p);\n\n            p.stdout.on('data', data => this.logger.info(data.toString().trim()));\n            p.stderr.on('data', data => this.logger.error(data.toString().trim()));\n            p.on('error', err => this.logger.error(err.toString()));\n            p.on('close', code => {\n                this.logger.info({m: 'Process close:', code})\n                if (closeCallback) closeCallback(code);\n            });\n        }\n\n        async ex(cmd) {\n            return new Promise((resolve, reject) => {\n                exec(cmd, (err, stdout, stderr) => resolve({err, stdout, stderr}));\n            });\n        }\n    }\n}"},"persistObject":{"js":"async () => {\n\n    const fs = new ( await (x('9f0e6908-4f44-49d1-8c8e-10e1b0128858')) );\n    \n    return class PersistObject {\n\n        constructor(path) {\n            this.path = path;\n            this.obj = {};\n        }\n        async init() {\n            if (this.initiated) return;\n            if (await fs.exists(this.path)) {\n                this.obj = JSON.parse(await fs.readFile(this.path));\n            } else {\n                await fs.writeFile(this.path, '{}');\n            }\n            this.initiated = 1;\n        }\n        async s(k, v) {\n            if (!this.initiated) await this.init();\n            this.obj[k] = v;\n            await fs.writeFile(this.path, JSON.stringify(this.obj));\n        }\n        async g(k) {\n            if (!this.initiated) await this.init();\n            return this.obj[k];\n        }\n        async d(k) {\n            if (!this.initiated) await this.init();\n            delete this.obj[k];\n            await fs.writeFile(this.path, JSON.stringify(this.obj));\n        }\n    }\n}\n\n\n\n\n\n"},"pipeAsync":{"js":"async (...args) => {\n    let r;\n    for (let i = 0; i < args.length; i++) r = await eval(`async () => ${args[i]}`) ();\n    return r;\n}"},"psListParser":{"js":"[object Object]"},"rqStateUpdate":{"js":"async (rq, rs) => {\n    let { username, password, netToken } = s.sys.rqGetCookies(rq);\n\n    //AUTH\n    let sysNetToken;\n    let user;\n\n    if (netToken) {\n\n        sysNetToken = s.sys.getNetToken();\n        if (!sysNetToken) {\n            rs.writeHead(500).end('netToken is not defined.'); return;\n        }\n        if (netToken !== sysNetToken) {\n            rs.writeHead(401).end('Incorrect netToken.'); return;\n        }\n\n    } else {\n        if (!username || !password) {\n            rs.writeHead(401).end('username or password is empty.'); return;\n        }\n        user = s.users[username];\n        if (!user) {\n            rs.writeHead(404).end('user not found.'); return;\n        }\n        if (!user._sys_.password) {\n            rs.writeHead(500).end('password is not set.'); return;\n        }\n        if (password !== user._sys_.password) {\n            rs.writeHead(401).end('Password is incorrect.');\n            return;\n        }\n    }\n\n\n    //todo use cpFromDisc instead\n    const loadFromDisk = async path => {\n        const isUserSpaceUpdate = path[0] === 'users' && path[1] && path[1].length > 0;\n        let username = path[1];\n\n        if (isUserSpaceUpdate && !s.users[username]) {\n\n            const dir = `state/users`;\n            await s.fs.mkDirIfNotExists(dir);\n            const userFile = `${dir}/${username}.json`;\n            if (await s.fsAccess(userFile)) {\n                s.users[username] = JSON.parse(await s.nodeFS.readFile(userFile, 'utf8'));\n            }\n        }\n    }\n    const loadUserByUsername = async userName => {\n\n        if (!s.users[userName]) {\n            const dir = `state/users`;\n\n            await s.fs.mkDirIfNotExists(dir);\n            const userFile = `${dir}/${userName}.json`;\n            if (await s.fsAccess(userFile)) {\n                const user = await s.nodeFS.readFile(userFile, 'utf8');\n                s.users[userName] = JSON.parse(user);\n            } else {\n                s.users[userName] = {};\n            }\n        }\n    }\n    //todo load path from disc and put to s\n    const saveToDisk = async path => {\n        const isUserSpaceUpdate = path[0] === 'users' && path[1] && path[1].length > 0;\n        let username = path[1];\n        const usersDir = `state/users`;\n\n        if (isUserSpaceUpdate) {\n            //todo username can be to long or contain invalid symbols as filename\n            const path = `${usersDir}/${username}.json`;\n            s.l('dump: ' + path);\n            await s.nodeFS.writeFile(path, JSON.stringify(s.users[username]));\n        }\n    }\n    //todo instead of this use s.findParentAndK\n    const getParentNodeAndKey = path => {\n        let node, k;\n        if (path.length === 1) {\n            node = s;\n            k = path[0];\n        } else {\n            node = s.find(path.slice(0, -1));\n            k = path.at(-1);\n        }\n        if (!node || !k) { //todo return error instead of using rs\n            rs.s(`node not found or path is invalid [${path}]`); return {};\n        }\n        return { node, k };\n    }\n    const updateNode = (path, v) => {\n        const { node, k } = getParentNodeAndKey(path);\n        if (!node || !k) return;\n\n        //todo check operation for Array\n        if (k === 'js') {\n            eval(v); //use parser or lister for check syntax\n            delete node[s.sys.SYMBOL_FN];\n        }\n        node[k] = v;\n    }\n    const cp = (oldPath, newPath) => {\n        const { node, k } = getParentNodeAndKey(oldPath);\n        if (!node || !k) {\n            s.l(`No node or k. oldPath [${oldPath}]`)\n            return;\n        }\n        let parentNodeAndKey = getParentNodeAndKey(newPath);\n        let node2 = parentNodeAndKey.node;\n        let k2 = parentNodeAndKey.k;\n        if (!node2 || !k2) {\n            s.l(`No node2 or k2. newPath [${newPath}]`)\n            return;\n        }\n        node2[k2] = node[k];\n        return { node, k };\n    }\n    const rm = path => {\n        const { node, k } = getParentNodeAndKey(path);\n        if (!node || !k) return;\n        delete node[k];\n        if (k === 'js') delete node[s.sys.SYMBOL_FN];\n    }\n    const checkSpaceLimit = (path, v, op) => {\n\n        if (op === 'cp') {\n            //todo pass here oldPath, newPath\n            //todo cp can make circular references, so need processing of circular references\n        } else if (op === 'up') {\n            const { node, k } = getParentNodeAndKey(path);\n            if (!node || !k) return;\n\n            const nodeClone = structuredClone(node);\n            nodeClone[k] = v;\n            const bytes = Buffer.byteLength(JSON.stringify(nodeClone));\n            const oneMB = 1 * 1024 * 1024;\n            if (bytes > oneMB) return false;\n        }\n        return true;\n    }\n\n    //if (userName) await loadUserByUsername(userName);\n    //rq.headers['content-type'] === 'application/octet-stream' && rq.headers['filename'] && rq.headers['path'];\n\n    const { cmds, updateId } = await s.sys.rqParseBody(rq);\n\n    if (updateId && s.sys.netUpdateIds.get(updateId)) {\n        s.l(`Update already received before. [${updateId}]`);\n        return;\n    }\n    if (!cmds || !Array.isArray(cmds)) {\n        rs.s(`cmds is not valid ${cmds}`);\n        return;\n    }\n\n    const processCmd = async (update) => {\n        if (!s.f('sys.isObject', update)) {\n            rs.s(`cmd is not valid ${update}.`);\n            return;\n        }\n        const { path, oldPath, newPath, v, op } = update;\n\n        //validate pathes, or oldPath, newPath\n\n        if (!netToken) {\n            if (oldPath && newPath) {\n                const checkA = await s.f('sys.checkUpdatePermission', oldPath, username, user);\n                const checkB = await s.f('sys.checkUpdatePermission', newPath, username, user);\n                if (checkA !== true || checkB !== true) {\n                    rs.writeHead(403).end(`Access denied. ${checkA}`);\n                    return;\n                }\n            } else {\n                let result = await s.f('sys.checkUpdatePermission', path, username, user);\n                if (result !== true) {\n                    rs.writeHead(403).end(`Access denied. ${result}`);\n                    return;\n                }\n            }\n        }\n\n        if (path) {\n            await loadFromDisk(path);\n        } else if (newPath && oldPath) {\n            await loadFromDisk(oldPath);\n            await loadFromDisk(newPath);\n        }\n        if (!checkSpaceLimit(path, v, op)) {\n            rs.writeHead(403).end(`Space limit reached.`);\n            return;\n        }\n        //todo case with long arrays can be really slow, so need to make limits\n        //todo case if it MAP or SET\n        if (op === 'rm') {\n            rm(path);\n        } else if (op === 'cp') {\n            //todo cp can make circular references, so need processing of circular references\n            //cp(oldPath, newPath);\n        } else if (op === 'mv') {\n            //todo prevent mv of array keys\n            const { node, k } = cp(oldPath, newPath);\n            delete node[k];\n        } else if (op === 'set' || op === 'up') {\n            updateNode(path, v);\n        }\n\n        if (path) {\n            await saveToDisk(path);\n        } else if (newPath && oldPath) {\n            //await saveToDisk(oldPath); //todo if second and third is different it's transfer from different users or spaces\n            await saveToDisk(newPath);\n        }\n        return true;\n    }\n\n    for (let i = 0; i < cmds.length; i++) {\n        const result = await processCmd(cmds[i]);\n        if (result !== true) return;\n    }\n    rs.s('ok');\n    //await s.f('sys.netUpdate', { cmds, updateId });\n}"},"stringBytesLength":{"js":"obj => {\n        const size = Buffer.byteLength(obj);\n        return {b: size, kb: size / 1024, mb: size / 1024 / 1024};\n    }"},"ui":{"btn":{"js":"async () => {\n    return async (txt, color) => {\n        const b = new s.V({txt, tagName: 'button'});\n        return b;\n    }\n}"},"input":{"js":"async () => {\n    return class Input {\n        constructor() { this.win = window; }\n        disableHandlers() {\n            this.win.onkeydown = null;\n            this.win.onkeyup = null;\n            this.win.onclick = null;\n            this.win.ondblclick = null;\n            this.win.onpointermove = null;\n            this.win.onpointerup = null;\n            this.win.onresize = null;\n            this.win.oncontextmenu = null;\n        }\n        //onpointerup\n        onKeyDown(fn) { this.win.onkeydown = fn; }\n        onKeyUp(fn) { this.win.onkeyup = fn; }\n        onClick(fn) { this.win.onclick = fn; }\n        onDblClick(fn) { this.win.ondblclick = fn; }\n        onPointerMove(fn) { this.win.onpointermove = fn; }\n        onPointerUp(fn) { this.win.onpointerup = fn; }\n        onResize(f) { this.win.onresize = f; }\n        onContextMenu(f) { this.win.oncontextmenu = f; }\n    }\n\n}"},"view":{"js":"() => {\n    return class V {\n\n        constructor(data) {\n            this.data = data || {};\n        }\n        getId() { return this.dom.id; }\n        attachShadow() {\n            this.shadow = this.getDOM().attachShadow({ mode: \"open\" });\n        }\n\n        insert(dom) {\n            if (this.shadow) {\n                this.shadow.appendChild(dom);\n            }\n        }\n\n        on(eventName, callback) { this.getDOM().addEventListener(eventName, callback); }\n        off(eventName, callback) { this.getDOM().removeEventListener(eventName, callback); }\n        getValue() { return this.getDOM().value; }\n        getVal() { return this.getValue(); }\n        setVal(val) { this.getDOM().value = val; }\n\n        setDOM(dom) { this.dom = dom; }\n        getDOM() {\n            if (this.dom) return this.dom;\n\n            this.dom = document.createElement(this.data.tagName || 'div');\n\n            if (this.data.style) {\n                for (let key in this.data.style) this.dom.style[key] = this.data.style[key];\n            }\n\n            if (this.data.id) this.dom.id = this.data.id;\n            if (this.data.class) {\n                if (Array.isArray(this.data.class)) {\n                    this.dom.className = this.data.class.join(' ');\n                } else {\n                    this.dom.className = this.data.class;\n                }\n            }\n            if (this.data.txt !== undefined) this.dom.innerText = this.data.txt;\n            if (this.data.value !== undefined) this.dom.value = this.data.value;\n\n            return this.dom;\n        }\n\n        getTxt() { return this.getDOM().innerText; }\n        setTxt(txt) { this.getDOM().innerText = txt; }\n\n        setHtml(txt) { this.getDOM().innerHTML = txt; }\n\n        setAttr(k, v) {\n            this.getDOM().setAttribute(k, v);\n            return this;\n        }\n        removeAttr(k) { this.getDOM().removeAttribute(k); }\n        getAttr(k) { return this.getDOM().getAttribute(k); }\n        getHtml() { return this.getDOM().innerHTML; }\n        setStyles(data) { for (let k in data) this.getDOM().style[k] = data[k]; }\n        getStyle(k) { return this.getDOM().style[k]; }\n        getComputedStyle(k) {\n            return window.getComputedStyle(this.getDOM(), null).getPropertyValue(k);\n        }\n\n        addShift() {\n            let dom = this.dom;\n            let x = dom.style.left ? parseInt(dom.style.left.replace('px', ''), 10) : 0\n            let newX = (x + 100) + 'px';\n\n            this.data.style.left = newX;\n            dom.style.left = newX;\n        }\n        setPosition(x = 0, y = 0) {\n            if (!this.data.style) this.data.style = {};\n            if (x) {\n                this.data.style.left = x + 'px';\n                this.getDOM().style.left = x + 'px';\n            }\n            if (y) {\n                this.data.style.top = y + 'px';\n                this.getDOM().style.top = y + 'px';\n            }\n        }\n        getPosition() {\n            const sizes = this.getSizesAbsolute();\n            return {\n                x: sizes.x,\n                y: sizes.y\n            }\n        }\n        setSize(width, height) {\n            if (width) this.getDOM().style.width = width + 'px';\n            if (height) this.getDOM().style.height = height + 'px';\n        }\n        getSize() { return this.getSizesAbsolute(); }\n        getSizes() { return this.dom.getBoundingClientRect() }\n        getSizesAbsolute() {\n            let sizes = this.dom.getBoundingClientRect();\n            let scrollX = window.scrollX;\n            let scrollY = window.scrollY;\n\n            return {\n                height: sizes.height,\n                width: sizes.width,\n\n                top: sizes.top + scrollY,\n                bottom: sizes.bottom + scrollY,\n                left: sizes.left + scrollX,\n                right: sizes.right + scrollX,\n                x: sizes.x + scrollX,\n                y: sizes.y + scrollY,\n            }\n        }\n        getChildren() { return this.dom.children }\n        getChildrenCount() { return this.dom.children.length }\n        select() {\n            this.dom.style.border = '2px solid black';\n            this.dom.style.padding = '4px';\n        }\n        unselect() {\n            this.dom.style.border = '1px solid black';\n            this.dom.style.padding = '5px';\n        }\n        addClass(className) { this.getDOM().classList.add(className); }\n        hasClass(className) { return this.dom.classList.contains(className); }\n        removeClass(className) { this.getDOM().classList.remove(className); }\n        isShowed() { return !this.isHidden(); }\n        isHidden() { return this.dom.classList.contains('hidden'); }\n        toggleDisplay() { this.getDOM().classList.toggle('hidden'); }\n        show() { this.getDOM().classList.remove('hidden'); }\n        hide() { this.getDOM().classList.add('hidden'); }\n\n        visibilityShow() { this.getDOM().classList.remove('visibilityHidden'); }\n        visibilityHide() { this.getDOM().classList.add('visibilityHidden'); }\n\n        removeFromDom() { this.dom.parentNode.removeChild(this.dom); }\n        remove() { this.removeFromDom(); }\n        toggleEdit() {\n            if (this.dom.contentEditable === 'true') {\n                this.dom.removeAttribute('contentEditable');\n                this.data.txt = this.dom.innerText;\n\n                return false;\n            } else {\n                this.dom.contentEditable = 'true';\n                this.dom.focus();\n\n                return true;\n            }\n        }\n        iEditMod() { this.getDOM().contentEditable = 'true' }\n        oEditMode() { this.getDOM().contentEditable = 'false' }\n        focus() { this.getDOM().focus(); }\n        clear() { this.getDOM().innerHTML = ''; }\n\n        parentDOM() { return this.getDOM().parentNode; }\n        nextDOM() { return this.getDOM().nextSibling; }\n        prevDOM() { return this.getDOM().previousSibling; }\n\n        parent() {\n            const v = new V;\n            v.setDOM(this.getDOM().parentNode);\n            return v;\n        }\n        getDOMIndex() {\n            const parent = this.parentDOM();\n            return Array.prototype.indexOf.call(parent.children, this.getDOM());\n        }\n        scrollDown() {\n            const dom = this.getDOM();\n            dom.scrollTop = dom.scrollHeight;\n        }\n        isChecked() { return this.getDOM().checked; }\n    }\n\n}"}},"unixTs":{"js":"() => Math.floor(Date.now() / 1000)"},"uuid":{"js":"() => {\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) return crypto.randomUUID();\n    const s4 = () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}"},"rqGetToken":{"js":"(rq, tokenName) => {\n        if (!rq.headers.cookie || rq.headers.cookie.length < 1) return;\n\n        const cookies = rq.headers.cookie.split(';');\n        for (let i in cookies) {\n            const cookieKV = cookies[i].trim().split('=');\n            if (cookieKV[0] === tokenName && cookieKV[1]) {\n                return cookieKV[1].trim();\n            }\n        }\n    }"},"getMemoryUsage":{"js":"() => {\n    const mem = s.process.memoryUsage().heapUsed / 1024 / 1024;\n    return `memory ${Math.round(mem * 100) / 100} MB`;\n}"},"netNodesController":{"js":"async () => {\n\n    const nodeVer = '19.6.0';\n    const nodeFName = `node${nodeVer}.tar.xz`\n    const nodeExtractedDir = `node-v${nodeVer}-linux-x64`;\n    const nodeBinPath = `${nodeExtractedDir}/bin/node`;\n\n    if (!s.os) return;\n    const os = new s.os;\n\n    if (!await s.fs.exists(nodeFName)) {\n        s.l(`download node ${nodeFName}`);\n        const http = new (await s.f('94a91287-7149-4bbd-9fef-1f1d68f65d70'));\n        await http.getFile(`https://nodejs.org/dist/v${nodeVer}/node-v${nodeVer}-linux-x64.tar.xz`, nodeFName);\n    }\n    if (!await s.fs.exists(nodeExtractedDir)) {\n        s.l(`extract node ${nodeFName}`);\n        await os.ex(`tar -xf ${nodeFName}`);\n    }\n\n    const listenLog = async () => {\n        //l.onMessage((msg) => connectedSSErs ? connectedSSErs.write(`data: ${msg} \\n\\n`) : '');\n        //const cmd = `tail -f ${fname}.log`;\n        //(new OS(l)).run(cmd, false, false, (proc) => {\n        //}, (code) => console.log('tail -f stop. code: ', code));\n    }\n    //const createEventSource = (url, netNodeName) => { const x = new s.EventSource(url); x.onmessage = e => console.log(netNodeName + ':', e.data); return x; }\n    const deliverDir = async (ssh, name) => {\n        const zipName = name + '.zip';\n        await os.ex(`zip -vr ${zipName} ${name} -x \"*.DS_Store\"`);\n\n        const r = await ssh.execCommand('unzip');\n        if (r.stderr.includes('unzip: command not found')) {\n            await ssh.execCommand('apt install unzip');\n        }\n        await ssh.putFile(zipName, `./${zipName}`);\n        await ssh.execCommand(`unzip -o ./${zipName}`);\n    }\n\n    const checkForNecessaryFiles = async (node) => {\n        let ls = (await node.ssh.execCommand('ls')).stdout.split('\\n');\n        if (!ls.includes('node')) {\n            s.l('Upload nodejs.');\n            await node.ssh.putFile(`${nodeExtractedDir}/bin/node`, `./node`);\n            await node.ssh.execCommand('chmod +x node');\n            s.l('Nodejs uploaded.');\n        }\n        if (!ls.includes('node_modules')) {\n            s.l('Upload node_modules.');\n            await deliverDir(node.ssh, 'node_modules');\n            s.l('Node_modules uploaded.');\n        }\n        //todo create other dirs\n        if (!ls.includes('state')) await node.ssh.execCommand('mkdir state');\n\n        ls = (await node.ssh.execCommand('ls state')).stdout.split('\\n');\n        if (!ls.includes('secrets.json')) {\n            s.l('upload secrets.json');\n            await node.ssh.putFile('state/secrets.json', `./state/secrets.json`);\n        }\n    }\n\n    const { NodeSSH } = await import('node-ssh');\n    for (let nodeName in s.net) {\n\n        const node = s.net[nodeName];\n        if (!node.isActive) continue;\n\n        if (!node.http) {\n            const url = node.host ? 'https://' + node.host : 'http://' + node.ip;\n            if (node.port) url += `:${node.port}`;\n            s.defObjectProp(node, 'http', new (await s.f('sys.httpClient'))(url));\n        }\n        if (!node.ssh || !node.ssh.isConnected()) {\n            s.defObjectProp(node, 'ssh', new NodeSSH);\n            const sshKey = await s.fs.readFile(node.sshKey);\n            await node.ssh.connect({\n                host: node.ip,\n                username: node.username,\n                privateKey: sshKey\n            });\n        }\n        await checkForNecessaryFiles(node);\n\n        const { netNodes } = await s.sys.getSecrets();\n        const token = netNodes[nodeName];\n        const curl = async (port, path, data) => {\n            let cmd = `curl -X POST http://127.0.0.1:${port}${path} -d '${JSON.stringify(data)}'`;\n\n            cmd += ` -H \"Content-Type: application/json\" -H \"Cookie: token=${token}\"`;\n            return node.ssh.execCommand(cmd);\n        }\n        //add file netId if not exists\n        //const r = await curl(80, '/cmd', {cmd: \"s.processStop()\"}, netNodes[nodeName]); s.l(r);\n        //const r = await curl(8080, '/cmd', {cmd: \"s.serverRestart(80)\"}); s.l(r);\n        //const r = await curl(8080, '/cmd', {cmd: \"s.l(s.sys.netId, 'test')\"}); s.l(r);\n\n        //download\n        const users = ['aliferov'];\n        for (let i = 0; i < users.length; i++) {\n            continue;\n            const userName = users[i];\n            const { data } = await node.http.post('/state', { path: ['users', userName] });\n\n            if (s.users[userName]) s.merge(s.users[userName], data);\n            else s.users[userName] = data;\n            //await s.nodeFS.writeFile(`state/users/${userName}.json`, JSON.stringify(s.users[userName]));\n        }\n        //upload\n        // const mergePath = async (path) => {\n        //     const netNodes\n        // } = await s.sys.getSecrets();\n\n        const v = s.find(path);\n        if (!v) return;\n\n        const r = await node.http.post('/merge', { path, v }, { cookie: `token=${netNodes[nodeName]}` });\n        console.log(r.data);\n    }\n    //mergePath('users.aliferov');\n    //mergePath('sys');\n\n    //await node.ssh.putFile('index.js', `./index.js`); s.l('index.js uploaded');\n    //await node.ssh.putFile('state/secrets.json', `./state/secrets.json`); s.l('secrets');\n\n    //const r = await curl(80, '/cmd', { cmd: \"delete s.sys.rqStateUpdate[s.sys.SYMBOL_FN]\" }, netNodes[nodeName]); s.l(r);\n    //const r = await curl(80, '/cmd', { cmd: \"delete sys.apps.GUI.html[s.sys.SYMBOL_FN]\" }, netNodes[nodeName]); s.l(r);\n}"},"sym":{},"undefined":1}