{"getSecrets":{"js":"async () => JSON.parse(await s.nodeFS.readFile('state/secrets.json', 'utf8'))"},"stateUpdateFull":{"js":"async state => {\n        for (let k in s) if (!state[k]) delete s[k];\n        s.merge(s, state);\n        s.l('setUpdate', 'setForUpdate: ', Object.keys(state).length);\n    }"},"stateUpdatePath":{"js":"(path, state) => {\n        const currentState = s.find(path);\n        for (let k in currentState) {\n            if (!state[k]) delete currentState[k];\n        }\n        //delete what not exists in state\n        s.merge(currentState, state);\n        s.l('setUpdate', path, Object.keys(state).length);\n    }"},"rqParseBody":{"js":"async (rq, limitMb = 12) => {\n\n        let limit = limitMb * 1024 * 1024;\n        return new Promise((resolve, reject) => {\n            let b = [];\n            let len = 0;\n\n            rq.on('data', chunk => {\n                len += chunk.length;\n                if (len > limit) {\n                    rq.destroy();\n                    resolve({err: `limit reached [${limitMb}mb]`});\n                    return;\n                }\n                b.push(chunk);\n            });\n            rq.on('error', err => reject(err));\n            rq.on('end', () => {\n                b = Buffer.concat(b);\n\n                if (rq.headers['content-type'] === 'application/json') {\n                    try { b = JSON.parse(b.toString()); }\n                    catch (e) { b = {err: 'json parse error'}; }\n                }\n                resolve(b);\n            });\n        });\n    }"},"rqParseQuery":{"js":"(rq) => {\n        const query = {};\n        const url = new URL('http://t.c' + rq.url);\n        url.searchParams.forEach((v, k) => {\n            query[k] = v\n        });\n        return query;\n    }"},"rqResolveStatic":{"js":"async (rq, rs) => {\n\n        const lastPart = rq.pathname.split('/').pop();\n        const split = lastPart.split('.');\n        if (split.length < 2) return false;\n\n        const extension = split[split.length - 1]; if (!extension) return;\n        try {\n            const file = await s.nodeFS.readFile('.' + rq.pathname);\n            const m = {html: 'text/html', js: 'text/javascript', css: 'text/css', map: 'application/json', woff2: 'font/woff2', woff: 'font/woff', ttf: 'font/ttf'};\n            if (m[extension]) rs.setHeader('Content-Type', m[extension]);\n\n            //rs.setHeader('Access-Control-Allow-Origin', '*');\n            rs.end(file);\n            return true;\n        } catch (e) {\n            if (s.log) s.log.info(e.toString(), {path: e.path, syscall: e.syscall});\n            else console.log(e);\n            return false;\n        }\n    }"},"rqGetCookies":{"js":"rq => {\n\n        const header = rq.headers.cookie;\n        if (!header || header.length < 1) {\n            return {};\n        }\n\n        const cookies = header.split('; ');\n        const result = {};\n        for (let i in cookies) {\n\n            const cookie = cookies[i].trim();\n            const index = cookie.indexOf('=');\n            if (index === -1) continue;\n\n            const k = cookie.slice(0, index);\n            const v = cookie.slice(index + 1);\n\n            if (!k || !v) continue;\n\n            result[k.trim()] = v.trim();\n        }\n        return result;\n    }"},"rqAuthenticate":{"js":"(rq) => {\n        let {token} = s.sys.rqGetCookies(rq);\n        return token && s.sys.token && token === s.sys.token;\n    }"},"httpRqHandler":{"js":"async (rq, rs) => {\n        const ip = rq.socket.remoteAddress;\n        const isLocal = ip === '::1' || ip === '127.0.0.1' || ip === '::ffff:127.0.0.1';\n        rq.isLocal = isLocal;\n\n        const url = new URL('http://t.c' + rq.url);\n        rq.pathname = url.pathname;\n        rq.mp = `${rq.method}:${url.pathname}`;\n        s.l(ip, rq.mp);\n\n        if (rq.pathname.includes('..')) {\n            rs.writeHead(403).end('Path include \"..\" denied.'); return;\n        }\n        if (rq.url.toLowerCase().includes('secrets.json')) {\n            rs.writeHead(403).end('denied secrets.json'); return;\n        }\n        rs.s = (v, contentType) => {\n            const s = (value, type) => rs.writeHead(200, {'Content-Type': type}).end(value);\n\n            if (!v) s('empty val', 'text/plain; charset=utf-8');\n            else if (v instanceof Buffer) s(v, '');\n            else if (typeof v === 'object') s(JSON.stringify(v), 'application/json');\n            else if (typeof v === 'string' || typeof v === 'number') s(v, contentType ?? 'text/plain; charset=utf-8');\n            else s('', 'text/plain');\n        }\n\n        const m = {\n            'POST:/cmd': async () => {\n                if (!isLocal || !s.sys.rqAuthenticate(rq)) {\n                    rs.writeHead(403).end('denied');\n                    return;\n                }\n                const {cmd} = await s.sys.rqParseBody(rq);\n                if (cmd) {\n                    try { eval(cmd); }\n                    catch (e) { console.log(e); }\n                }\n            },\n            'GET:/trigger': async () => {\n                if (!isLocal) return;\n                if (s.trigger) s.trigger();\n            },\n            'GET:/': async () => rs.s(await s.f('sys.apps.GUI.html'), 'text/html'),\n            'GET:/stream': async () => {\n                const rqId = await s.f('sys.uuid');\n\n                s.log.info('SSE connected');\n                s.connectedSSERequests.set(rqId, rs);\n                rs.writeHead(200, {'Content-Type': 'text/event-stream', 'Connection': 'keep-alive', 'Cache-Control': 'no-cache'});\n\n                rq.on('close', () => {\n                    s.connectedSSERequests.delete(rqId);\n                    s.log.info('SSE closed');\n                });\n                rq.isLongRequest = true;\n            },\n            'GET:/module.js': async () => {\n                const {id} = sys.rqParseQuery(rq);\n                if (!id) {\n                    rs.writeHead(400).end('id is invalid.'); return;\n                }\n                const obj = s.find(id);\n                if (obj && obj.js) {\n                    rs.setHeader('Content-Type', 'text/javascript');\n                    rs.end('export default ' + obj.js);\n                }\n            },\n            'POST:/state': async () => {\n                const {path} = await s.sys.rqParseBody(rq);\n                if (!Array.isArray(path)) {\n                    rs.writeHead(403).end('Path is invalid.'); return;\n                }\n                if (path[0] === 'sys') {\n                    if (path[1] === 'secrets' || path[1] === 'token') {\n                        rs.writeHead(403).end('Access denied.'); return;\n                    }\n                }\n\n                let node = s.find(path);\n                const pathStr = 'state/' + path.join('/');\n\n                //todo get path info will be better\n                if (typeof node === 'object' && !Array.isArray(node) && Object.keys(node).length < 1) {\n\n                    if (await s.fsAccess(pathStr)) {\n                        const list = await s.nodeFS.readdir(pathStr);\n                        for (let i = 0; i < list.length; i++) {\n                            const item = list[i];\n                            if (!item.endsWith('.json')) continue;\n                            const id = item.slice(0, -5);\n                            if (!node[id]) node[id] = {};\n                        }\n\n                    } else if (await s.fsAccess(pathStr + '.json')) {\n                        const {parent, k} = s.findParentAndK(path);\n                        node = JSON.parse(await s.nodeFS.readFile(pathStr + '.json', 'utf8'));\n                        if (parent && k) parent[k] = node;\n                    }\n                }\n                //todo level of depth of object or array\n                rs.s(node);\n            },\n            'POST:/stateUpdate': async () => {\n                if (!s.sys.rqStateUpdate) {\n                    rs.s('Server state is not ready.'); return;\n                }\n                await s.f('sys.rqStateUpdate', rq, rs);\n            },\n            'POST:/sysUpdate': async () => {\n                if (!s.sys.rqAuthenticate(rq)) {\n                    rs.writeHead(403).end('denied');\n                    return;\n                }\n                const {sys} = await s.sys.rqParseBody(rq);\n                s.merge(s.sys, sys);\n                rs.s('ok');\n            },\n            'POST:/sign/in': async () => {\n                //todo add rate limit\n                const {token} = await s.sys.rqParseBody(rq);\n                if (!token || typeof token !== 'string') {\n                    rs.writeHead(400).end('Token is invalid.');\n                    return;\n                }\n                const {users} = await s.sys.getSecrets();\n                if (!users[token]) {\n                    rs.writeHead(404).end('User not found.');\n                    return;\n                }\n                rs.writeHead(200, {\n                    'Set-Cookie': `token=${token}; Path=/; Max-Age=2580000; SameSite=Strict; Secure; HttpOnly`,\n                    'Content-Type': 'text/plain'\n                }).end('ok');\n            },\n            'POST:/sign/out': async () => {\n                rs.writeHead(200, {\n                    'Set-Cookie': `token=str; Path=/; Max-Age=-1; SameSite=Strict; Secure; HttpOnly`,\n                    'Content-Type': 'text/plain'\n                }).end('ok');\n            },\n            // 'GET:/authorizedUser': async () => {\n            //     const cookies = s.sys.rqGetCookies(rq);\n            //     if (!cookies.token) {\n            //         rs.s({userName: null});\n            //         return;\n            //     }\n            //     const users = (await s.sys.getSecrets()).users;\n            //     let userName = users[cookies.token];\n            //     rs.s({userName});\n            // },\n            'POST:/uploadFile': async () => {\n                if (!rq.isLocal) { rs.writeHead(403).end('denied'); return; }\n\n                const b = await s.sys.rqParseBody(rq);\n                if (b.err) return;\n                if (b) await s.nodeFS.writeFile('testFIL', b);\n                rs.s('ok');\n            },\n        }\n\n        if (!rq.mp.startsWith('GET:/module.js')) {\n            if (s.sys.rqResolveStatic && await s.sys.rqResolveStatic(rq, rs)) return;\n        }\n        if (m[rq.mp]) {\n            try { await m[rq.mp](); }\n            catch (e) {\n                s.log ? s.log.error(e) : console.log(e);\n                rs.writeHead(500).end('Internal server error.');\n            }\n        }\n        if (!rq.isLongRequest && !rs.writableEnded) {\n            rs.s('Default response.');\n        }\n    }"},"loopDelay":2000,"checkUpdatePermission":{"js":"async (path, userName, user) => {\n    if (userName === 'root') return true;\n\n    const perms = user._sys_ ? (user._sys_.permissions || {})  : {};\n\n    if (path[0] === 'users') {\n        if (path[1] !== userName) {\n\n            if (perms.changeOtherUsers) return true;\n\n            return \"You can't change other users namespaces.\";\n        }\n        if (path[2] === '_sys_') {\n            return \"You can't change system data.\";\n        }\n    } else {\n        if (perms.changeSys) return true;\n\n        return \"You can't change system namespaces.\";\n    }\n    return true;\n}"},"netUpdate":{"js":"async (update, token, isSysUpdate) => {\n\n    const sys = s.sys;\n    if (!sys) return;\n\n    const updateIds = sys.netUpdateIds;\n    const del = id => setTimeout(() => updateIds.delete(id), 20000);\n\n    let updateId = update.updateId;\n    if (updateId) {\n        updateIds.set(updateId, 1);\n        s.l(`Update received. [${updateId}]`);\n        del(updateId);\n    } else {\n        const newUpdateId = s.f('sys.uuid');\n        updateIds.set(newUpdateId, 1);\n        update.updateId = newUpdateId;\n        del(newUpdateId);\n    }\n\n    const secretsNetNodes = (await sys.getSecrets()).netNodes;\n\n    for (let nodeName in s.net) {\n\n        const node = s.net[nodeName];\n        if (!node.isActive || nodeName === s.sys.netId) {\n            s.l(`skip node [${nodeName}]`); continue;\n        }\n        try {\n            const url = node.host ? 'https://' + node.host : 'http://' + node.ip;\n            const http = new (await s.f('sys.httpClient'));\n            const finalToken = isSysUpdate ? secretsNetNodes[nodeName] : token;\n\n            const r = await http.post(url + '/stateUpdate', update, {cookie: `token=${finalToken}`});\n            s.l(`UPDATE [${nodeName}]`, 'resp:', r.data);\n        } catch (e) {\n            s.l(`error making update of node`, );\n        }\n    }\n}"},"netNodesCheck":{"js":"async () => {\n\n    return async netId => {\n\n        if (netId !== 'aliferovMac') return;\n\n        const nodeVer = '19.6.0';\n        const nodeFName = `node${nodeVer}.tar.xz`\n        const nodeExtractedDir = `node-v${nodeVer}-linux-x64`;\n        const nodeBinPath = `${nodeExtractedDir}/bin/node`;\n\n        if (!s.os) return;\n        const os = new s.os;\n\n        if (!await s.fs.exists(nodeFName)) {\n            s.l(`download node ${nodeFName}`);\n            const http = new (await s.f('94a91287-7149-4bbd-9fef-1f1d68f65d70'));\n            await http.getFile(`https://nodejs.org/dist/v${nodeVer}/node-v${nodeVer}-linux-x64.tar.xz`, nodeFName);\n        }\n        if (!await s.fs.exists(nodeExtractedDir)) {\n            s.l(`extract node ${nodeFName}`);\n            await os.ex(`tar -xf ${nodeFName}`);\n        }\n\n        const listenLog = async () => {\n            //l.onMessage((msg) => connectedSSErs ? connectedSSErs.write(`data: ${msg} \\n\\n`) : '');\n            //const cmd = `tail -f ${fname}.log`;\n            //(new OS(l)).run(cmd, false, false, (proc) => {\n            //}, (code) => console.log('tail -f stop. code: ', code));\n        }\n        //const createEventSource = (url, netNodeName) => { const x = new s.EventSource(url); x.onmessage = e => console.log(netNodeName + ':', e.data); return x; }\n        const deliverDir = async (ssh, name) => {\n            const zipName = name + '.zip';\n            await os.ex(`zip -vr ${zipName} ${name} -x \"*.DS_Store\"`);\n\n            const r = await ssh.execCommand('unzip');\n            if (r.stderr.includes('unzip: command not found')) {\n                await ssh.execCommand('apt install unzip');\n            }\n            await ssh.putFile(zipName, `./${zipName}`);\n            await ssh.execCommand(`unzip -o ./${zipName}`);\n        }\n\n        const checkForNecessaryFiles = async (node) => {\n            let ls = (await node.ssh.execCommand('ls')).stdout.split('\\n');\n            if (!ls.includes('node')) {\n                s.l('upload nodejs');\n                await node.ssh.putFile(`${nodeExtractedDir}/bin/node`, `./node`);\n                await node.ssh.execCommand('chmod +x node');\n                s.l('nodejs uploaded');\n            }\n            if (!ls.includes('node_modules')) {\n                s.l('upload node_modules');\n                await deliverDir(node.ssh, 'node_modules');\n                s.l('node_modules uploaded');\n            }\n            if (!ls.includes('state')) await node.ssh.execCommand('mkdir state');\n\n            ls = (await node.ssh.execCommand('ls state')).stdout.split('\\n');\n            if (!ls.includes('secrets.json')) {\n                s.l('upload secrets.json');\n                await node.ssh.putFile('state/secrets.json', `./state/secrets.json`);\n            }\n        }\n\n        const {NodeSSH} = await import('node-ssh');\n        for (let nodeName in s.net) {\n\n            const node = s.net[nodeName];\n            if (!node.isActive) continue;\n            if (!node.http) {\n                const url = node.host ? 'https://' + node.host : 'http://' + node.ip;\n                s.defObjectProp(node, 'http', new (await s.f('sys.httpClient'))(url));\n            }\n            if (!node.ssh || !node.ssh.isConnected()) {\n                s.defObjectProp(node, 'ssh', new NodeSSH);\n                const sshKey = await s.fs.readFile(node.sshKey);\n                await node.ssh.connect({\n                    host: node.ip,\n                    username: node.username,\n                    privateKey: sshKey});\n            }\n            await checkForNecessaryFiles(node);\n\n            const {netNodes} = await s.sys.getSecrets();\n            const token = netNodes[nodeName];\n            const curl = async (port, path, data) => {\n                let cmd = `curl -X POST http://127.0.0.1:${port}${path} -d '${JSON.stringify(data)}'`;\n\n                cmd += ` -H \"Content-Type: application/json\" -H \"Cookie: token=${token}\"`;\n                return node.ssh.execCommand(cmd);\n            }\n            //add file netId if not exists\n            //const r = await curl(80, '/cmd', {cmd: \"s.processStop()\"}, netNodes[nodeName]); s.l(r);\n            //const r = await curl(8080, '/cmd', {cmd: \"s.serverRestart(80)\"}); s.l(r);\n            //const r = await curl(8080, '/cmd', {cmd: \"s.l(s.sys.netId, 'test')\"}); s.l(r);\n            //state update\n\n            //await node.ssh.putFile('index.js', `./index.js`); s.l('index.js uploaded')\n            //todo sync users and spaces\n            const users = ['vlada', 'llanosrocas']; //'llanosrocas'\n            for (let i = 0; i < users.length; i++) {\n                continue;\n\n                const userName = users[i];\n                const {data} = await node.http.post('/state', {path: ['users', userName]});\n\n                if (s.users[userName]) s.merge(s.users[userName], data);\n                else s.users[userName] = data;\n                await s.nodeFS.writeFile(`state/users/${userName}.json`, JSON.stringify(s.users[userName]));\n            }\n\n            const sendSys = async () => {\n                const {netNodes} = await s.sys.getSecrets();\n                const r = await node.http.post('/sysUpdate', {sys: s.sys}, {cookie: `token=${netNodes[nodeName]}`});\n                console.log(r.data);\n            }\n            //sendSys();\n            //const r = await curl(80, '/cmd', {cmd: \"delete s.sys.rqStateUpdate[s.sys.SYMBOL_FN]\"}, netNodes[nodeName]); s.l(r);\n        }\n    }\n}"},"setUpdate":{"js":"async state => {\n\n        const t = s.sys.token;\n        for (let k in s) if (!state[k]) delete s[k];\n        for (let k in state) s[k] = state[k];\n        s.sys.token = t;\n\n        s.def('loadStateDone', 1);\n        s.l('setUpdate', 'setForUpdate: ', Object.keys(state).length, 'set: ', Object.keys(s).length);\n    }"},"rqAuthenticateByToken":{"js":"(rq) => {\n        let {token} = s.sys.rqGetCookies(rq);\n        return token && s.sys.token && token === s.sys.token;\n    }"},"parseCliArgs":{"js":"(cliArgs) => {\n\n        const args = {};\n\n        for (let i = 0; i < cliArgs.length; i++) {\n            if (i < 2) continue; //skip node scriptName args\n\n            let arg = cliArgs[i];\n            let [k, v] = arg.split('=');\n            if (!v) {\n                args[i - 2] = arg; //start write args from main 0\n                continue;\n            }\n            k = k.slice(2); //remove \"--\" characters\n            args[k.trim()] = v.trim();\n        }\n\n        return args;\n    }"},"logger":{"js":"() => {\n    return class Logger {\n        constructor(prefix = '') {\n            this.prefix = prefix;\n            this.isMuted = 0;\n        }\n        mute() { this.isMuted = 1 } unmute() { this.isMuted = 0 }\n        onMessage(handler) { this.handler = handler; return this; }\n\n        async log() {\n            let s = this.prefix + '';\n            \n            for (let i = 0; i < arguments.length; i++) {\n                const m = arguments[i];\n                const isObjOrArray = typeof m === 'object' && m !== null;\n\n                if (m instanceof Error) {\n                    s += m.stack ?? m.toString();\n                } else {\n                    s += isObjOrArray ? ' ' + JSON.stringify(m) : m;\n                }\n            }\n            if (!this.isMuted) console.log(s);\n            if (this.handler) this.handler(s);\n        }\n        async info() { await this.log(...arguments); }\n        async error() { await this.log(...arguments); }\n    }\n}"},"cloneObject":{"js":"obj => {\n\n    if (Array.isArray(obj)) {\n        let array = [];\n        for (let i = 0; i < obj.length; i++) {\n\n            const v = obj[i];\n            const t = typeof v;\n\n            if (t === 'function') continue;\n            if (t === 'object' && v !== null) {\n                array.push(cloneObject(v));\n            } else {\n                array.push(v);\n            }\n        }\n        return array;\n    }\n\n    let clone = {};\n    for (let k in obj) {\n        const v = obj[k];\n        const t = typeof v;\n        if (t === 'function') continue;\n        clone[k] = (t === 'object' && v !== null) ? cloneObject(v) : v;\n    }\n    return clone\n}"},"apps":{"GUI":{"js":"async () => {\n    return class GUI {\n\n        async globals() {\n            //todo reactivity for deps and realtime updates\n            this.http = new (await s.f('sys.httpClient'));\n            this.v = await s.f('sys.ui.view');\n\n            s.sys.eventHandlers = {};\n\n            globalThis.e = new Proxy(() => {}, {\n                apply(target, thisArg, args) {\n                    const handler = args[0];\n                    const data = args[1];\n                    if (s.sys.eventHandlers[handler]) {\n                        return s.sys.eventHandlers[handler](data);\n                    }\n                },\n                set(target, k, v) {\n                    s.sys.eventHandlers[k] = v;\n                    return true;\n                }\n            });\n            s.def('e', e);\n\n            s.e['>'] = (args) => {\n                let [v1, v2, index] = args;\n\n                if (v1.getV) v1 = v1.getV();\n                if (v2.getV) v2 = v2.getV();\n\n                if (index !== undefined) {\n                    v2.getDOM().insertBefore(v1.getDOM(), v2.getDOM().children[index]);\n                    return;\n                }\n                v2.getDOM().append(v1.getDOM());\n            }\n            s.e['>before'] = (args) => {\n                const [domA, domB] = args;\n                domB.getDOM().before(domA.getDOM())\n            }\n            s.e['>after'] = (args) => {\n                const [domA, domB] = args;\n                domB.getDOM().after(domA.getDOM())\n            }\n        }\n\n        async start() {\n            await this.globals();\n            s.sys.proxyS.set = (obj, prop, val) => {\n                if (prop === 'isTerminalShowed') {\n                    if (val) localState.set('isTerminalShowed', 1)\n                    else localState.del('isTerminalShowed');\n                    return false;\n                }\n                return Reflect.set(obj, prop, val);\n            }\n\n            // const baseUrl = document.location.protocol + '//' + document.location.host;\n            // require.config({ paths: { 'vs': baseUrl + '/node_modules/monaco-editor/min/vs' }});\n            // window.MonacoEnvironment = {\n            //     getWorkerUrl: (workerId, label) => {\n            //         return `data:text/javascript;charset=utf-8,${encodeURIComponent(`\n            //     self.MonacoEnvironment = { baseUrl: '${baseUrl}/node_modules/monaco-editor/min/' };\n            //     importScripts('${baseUrl}/node_modules/monaco-editor/min/vs/base/worker/workerMain.js');`\n            //         )}`;\n            //     }\n            // };\n            // await (new Promise((resolve, reject) => {\n            //     require([\"vs/editor/editor.main\"], () => resolve());\n            // }));\n\n            const input = new (await s.f('sys.ui.input'));\n            input.onKeyDown(async (e) => await outliner.handleKeyDown(e));\n            input.onKeyUp(async (e) => await outliner.handleKeyUp(e));\n            input.onClick(async (e) => await outliner.handleClick(e));\n            input.onDblClick(async (e) => await outliner.handleDblClick(e));\n            input.onContextMenu(e => outliner.handleContextMenu(e));\n            this.input = input;\n\n            e['openNode'] = async ({appPath = 'apps.monacoEditor', outlinerNode}) => {\n                const dataNode = outlinerNode.getDataNode();\n                dataNode.setPath(outlinerNode.getPath().join('.'));\n\n                await appsManager.openApp(appPath, dataNode);\n                appsManager.updateFocusedAppContainerDimensions();\n            }\n            e['outlinerSizeChanged'] = outlinerWidth => {\n\n                localState.setOutlinerWidth(outlinerWidth);\n\n                const appContainerWidth = window.innerWidth - outlinerWidth - this.resizer.getSizes().width;\n                appsManager.setWidth(appContainerWidth);\n            }\n            e['terminalSizeChanged'] = () => {\n                s.e('recalcDimensions');\n            }\n            e['recalcDimensions'] = () => {\n                const height = window.innerHeight - terminal.getHeight();\n\n                outliner.setHeight(height - runBtn.getSizes().height);\n                appsManager.setHeight(height);\n\n                const appContainerWidth = window.innerWidth - this.outliner.getWidth() - this.resizer.getSizes().width;\n                appsManager.setWidth(appContainerWidth);\n            }\n            e['getDimensionsForAppContainer'] = () => {\n                return {\n                    width: window.innerWidth - this.outliner.getWidth() - this.resizer.getSizes().width,\n                    height: window.innerHeight - terminal.getHeight() - appsManager.getTabsHeight()\n                }\n            };\n            e['state.update'] = async ({outlinerNode, dataNode, data}) => {\n\n                if (!dataNode) dataNode = outlinerNode.getDataNode();\n                dataNode.setData(data);\n\n                let path, k;\n                if (outlinerNode) {\n                    path = outlinerNode.getPath();\n                    if (!path || path.length < 1) return;\n\n                    const parentDataNode = outlinerNode.getParent().getDataNode();\n                    k = path.at(-1);\n                    parentDataNode.set(k, data);\n                } else {\n                    path = dataNode.getPath();\n                    if (typeof path === 'string') {\n                        path = path.split('.');\n                    }\n                    const parent = path.length > 1 ? s.find(path.slice(0, -1)) : s;\n                    k = path.at(-1);\n                    if (parent && k) parent[k] = data;\n                }\n                if (path) {\n                    await this.http.post('/stateUpdate', { cmds: [{ path, v: data, op: 'set' }] });\n                    if (k === 'js') {\n                        const { parent } = s.findParentAndK(path);\n                        if (parent) delete parent[s.sys.SYMBOL_FN];\n                    }\n                }\n            }\n            e['state.mv'] = async ({oldPath, newPath}) => {}\n            e['state.del'] = async ({outlinerNode, dataNode}) => {\n                //todo case  for dataNode\n                const path = outlinerNode.getPath();\n                await this.http.post('/stateUpdate', {cmds: [{path, op: 'rm'}] });\n\n                const parentOutlinerNode = outlinerNode.getParent();\n                const parentDataNode = parentOutlinerNode.getDataNode();\n                parentDataNode.del(path.at(-1));\n\n                if (parentDataNode.isEmpty()) parentOutlinerNode.openCloseBtnHide();\n                outlinerNode.remove();\n            }\n            s.e['outlinerNode.ui.add'] = ({outlinerNode}) => {\n                this.outliner.nodes.set(outlinerNode.getId(), outlinerNode);\n            }\n            s.e['outlinerNode.ui.remove'] = id => {\n                this.outliner.nodes.delete(id);\n            }\n            s.e['outlinerNode.find'] = id => {\n                const node = this.outliner.nodes.get(id);\n                if (!node) {\n                    s.l(id, this.outliner.nodes);\n                }\n                return node;\n            }\n            e['app.addViewElement'] = v => e('>', [v, app]);\n\n            //BUILDING UI\n            const app = new this.v;\n            app.setDOM(document.getElementById('app'));\n\n            const mainContainer = new this.v({class: ['mainContainer', 'flex']});\n            this.mainContainer = mainContainer;\n            e('>', [mainContainer, app]);\n\n            const localState = new (await s.f('sys.apps.GUI.localState'));\n\n            s.sys.popup = new (await s.f('sys.apps.GUI.popup'));\n            e('>', [s.sys.popup, app]);\n\n            //todo change sideBarWith not outliner\n            const sideBar = new this.v({class: ['sideBar']})\n            e('>', [sideBar, mainContainer]);\n\n            const runBtn = new this.v({class: 'burger-btn'});\n            e('>', [runBtn, sideBar]);\n            [1,1,1].forEach(() => e('>', [new this.v({ class: 'burger-line' }), runBtn]));\n\n            runBtn.on('pointerdown', (e) => {\n                e.stopPropagation();\n                runBtn.addClass('active');\n\n                const popup = s.sys.popup; popup.clear();\n                const createBtn = (txt) => new this.v({ txt, class: ['btn', 'contextMenu', 'white', 'hoverGray'] });\n\n                let oBtn = createBtn('Auth');\n                oBtn.on('click', () => {\n                    popup.clear();\n                    const authBar = new (s.f('sys.apps.GUI.authBar'));\n                    authBar.init(this.v, this.http);\n                    s.e('>', [authBar, popup]);\n                });\n                //oBtn.on('pointerenter', removeSubmenu);\n                window.e('>', [oBtn, popup]);\n\n                // oBtn = createBtn('Sign out');\n                // oBtn.on('click', () => {\n                //     popup.clear();\n                // });\n                //oBtn.on('pointerenter', removeSubmenu);\n                //window.e('>', [oBtn, popup]);\n\n                popup.putRightTo(runBtn);\n            });\n\n            //1. UI OUTLINER\n            const outliner = new (await s.f('sys.apps.GUI.outliner'));\n            this.outliner = outliner;\n            await outliner.init(localState, input);\n            e('>', [outliner.getV(), sideBar]);\n\n            //2. UI RESIZER\n            this.resizer = new this.v({class: 'resizer'});\n            e('>', [this.resizer, mainContainer]);\n            e('>', [new this.v({class: 'left'}), this.resizer]);\n            e('>', [new this.v({class: 'center'}), this.resizer]);\n            this.resizerDragAndDrop();\n\n            //3. UI APPS MANAGER\n            const appsManager = new (await s.f('sys.apps.GUI.appsManager'));\n            await appsManager.init(localState);\n            e('>', [appsManager.getV(), mainContainer]);\n\n            //4. UI TERMINAL\n            const terminal = new (await s.f('sys.apps.GUI.terminal'))(localState, input);\n            e('>', [terminal.getV(), mainContainer]);\n            terminal.init();\n\n            let outlinerWidth = Number(localState.getOutlinerWidth() ?? outliner.getWidth() + 100);\n            outliner.getV().setStyles({width: outlinerWidth + 'px'});\n            e('outlinerSizeChanged', outlinerWidth);\n\n            mainContainer.on('pointerdown', () => s.sys.popup.clear());\n            input.onResize(e => s.e('recalcDimensions'));\n\n            //localState.set('isTerminalShowed', '');\n            if (!localState.get('isTerminalShowed')) {\n                //terminal.hide();\n                //localState.set('isTerminalShowed', '');\n            }\n\n            const eventSource = () => {\n                const sse = new EventSource('/stream');\n                sse.onmessage = (event) => {\n                    let msg = '';\n                    try {\n                        msg = JSON.parse(event.data);\n                    } catch (e) {\n                        console.error(e);\n                        return;\n                    }\n                    s.l(msg);\n                }\n                sse.onerror = (e) => console.log('An error occurred while attempting to connect.', e);\n            }\n            eventSource();\n        }\n\n        resizerDragAndDrop() {\n            let resizerSizes;\n            let shift;\n\n            const outlinerPadding = this.outliner.getHorizontalPadding();\n\n            const move = e => {\n                const mouseX = e.clientX;\n                if (mouseX < 20 || mouseX > (window.innerWidth - 20)) return;\n\n                const oulinerWidth = mouseX - outlinerPadding - resizerSizes.width + shift;\n\n                this.outliner.getV().setStyles({width: oulinerWidth + 'px'});\n                window.e('outlinerSizeChanged', oulinerWidth);\n            }\n            this.resizer.on('pointerdown', e => {\n                s.sys.popup.clear();\n\n                e.preventDefault();\n                resizerSizes = this.resizer.getSizes();\n                shift = (resizerSizes.x + resizerSizes.width) - e.clientX;\n\n                this.input.onMouseMove(move);\n                this.input.onMouseUp(() => {\n                    this.input.onMouseUp(null);\n                    this.input.onMouseMove(null);\n                });\n            });\n        }\n    }\n}","html":{"js":"async () => {\n\nreturn `\n\n<!DOCTYPE html>\n<html lang=\"en\" data-theme=\"light\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n    <title>radiator</title>\n    <link rel=\"icon\" href=\"data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>âœ¨</text></svg>\">\n    <style>\n        :root {\n            --bg-color: white;\n            --keyword-color: #0033B3;\n            --name-color: #248F8F;\n            --op-color: black;\n            --string-color: #067D17;\n            --number-color: #1750EB;\n            --prop-name-color: #971796;\n            --function-color: #A77C43;\n            --bracket-color: black;\n            --standart-line-height: 1.55em;\n            --shift: 1.2em;\n        }\n        :root .prose {\n            --tw-prose-body: hsla(var(--bc)/.8);\n            --tw-prose-headings: hsl(var(--bc));\n            --tw-prose-lead: hsl(var(--bc));\n            --tw-prose-links: hsl(var(--bc));\n            --tw-prose-bold: hsl(var(--bc));\n            --tw-prose-counters: hsl(var(--bc));\n            --tw-prose-bullets: hsla(var(--bc)/.5);\n            --tw-prose-hr: hsla(var(--bc)/.2);\n            --tw-prose-quotes: hsl(var(--bc));\n            --tw-prose-quote-borders: hsla(var(--bc)/.2);\n            --tw-prose-captions: hsla(var(--bc)/.5);\n            --tw-prose-code: hsl(var(--bc));\n            --tw-prose-pre-code: hsl(var(--nc));\n            --tw-prose-pre-bg: hsl(var(--n));\n            --tw-prose-th-borders: hsla(var(--bc)/.5);\n            --tw-prose-td-borders: hsla(var(--bc)/.2)\n        }\n        [data-theme=light] {\n            color-scheme: light;\n            --bg-color: hsl(var(--b2, var(--b1)));\n            --pf: 258.89 94.378% 40.941%;\n            --sf: 314 100% 37.647%;\n            --af: 174 60% 40.784%;\n            --nf: 219 14.085% 22.275%;\n            --in: 198 93% 60%;\n            --su: 158 64% 52%;\n            --wa: 43 96% 56%;\n            --er: 0 91% 71%;\n            --inc: 198 100% 12%;\n            --suc: 158 100% 10%;\n            --wac: 43 100% 11%;\n            --erc: 0 100% 14%;\n            --rounded-box: 1rem;\n            --rounded-btn: .5rem;\n            --rounded-badge: 1.9rem;\n            --animation-btn: .25s;\n            --animation-input: .2s;\n            --btn-text-case: uppercase;\n            --btn-focus-scale: .95;\n            --border-btn: 1px;\n            --tab-border: 1px;\n            --tab-radius: .5rem;\n            --p: 258.89 94.378% 51.176%;\n            --pc: 0 0% 100%;\n            --s: 314 100% 47.059%;\n            --sc: 0 0% 100%;\n            --a: 174 60% 50.98%;\n            --ac: 174.71 43.59% 15.294%;\n            --n: 219 14.085% 27.843%;\n            --nc: 0 0% 100%;\n            --b1: 0 0% 100%;\n            --b2: 0 0% 94.902%;\n            --b3: 180 1.9608% 90%;\n            --bc: 215 27.907% 16.863%;\n        }\n        .darkTheme {\n            --bg-color: #2B2B2B;\n            --keyword-color: #CC7832;\n            --name-color: #A7B2BE;\n            --op-color: #A7B2BE;\n            --string-color: #4E6E4E;\n            --number-color: #6195BB;\n            --prop-name-color: #726BA7;\n            --function-color: #FBC169;\n            --bracket-color: #A7B2BE;\n        }\n        body {\n            margin: 0;\n            color: hsl(var(--bc));\n            font-family: Helvetica, Tahoma, Arial, sans-serif;\n            font-size: 15px;\n            background: var(--bg-color);\n            overflow: hidden;\n            -webkit-text-size-adjust: 100%;\n        }\n        #app {\n            overflow: hidden;\n        }\n        .mainContainer {\n            overflow: hidden;\n        }\n        /*#app { */\n        /*    display: grid; */\n        /*    grid-template-columns: auto 80%;*/\n        /*    min-height: 100vh; */\n        /*}*/\n        .popup {\n            position: absolute;\n            opacity: 0.97;\n            z-index: 5;\n            box-shadow: rgba(0, 0, 0, 0.50) 0px 2px 8px;\n        }\n        .popup .btn.contextMenu {\n            color: hsl(var(--bc));\n            padding-right: 30px;\n        }\n\n        /*.pageSign {*/\n        /*    display: flex;*/\n        /*    justify-content: center;*/\n        /*    justify-self: center;*/\n        /*}*/\n        /*.signContainer {*/\n        /*    display: flex;*/\n        /*    justify-content: center;*/\n        /*    width: 15em;*/\n        /*    margin-top: 5em;*/\n        /*    padding: 25px;*/\n        /*    background: #dcdde1;*/\n        /*}*/\n        /*.signBlock input { width: 15em; }*/\n\n        .runBtn {\n            width: 1.3em;\n            height: 0.8em;\n            background: rgba(18,199,5,0.99);\n        }\n\n        .outliner {\n            background: var(--bg-color);\n            overflow: scroll;\n            padding: 0 7px;\n        }\n        .outliner > .node > .nodeContainer > .openClose { display: none; }\n        .outlinerHeader {\n            line-height: 30px;\n            min-height: 30px;\n            font-weight: bold;\n            white-space: nowrap;\n        }\n        .nodeContainer .quote { color: #AA1011; }\n\n        .resizer {\n            display: flex;\n            cursor: col-resize;\n        }\n        .resizer .left {\n            width: 4px;\n            height: 100%;\n        }\n        .resizer .center {\n            background: lightgray;\n            width: 1px;\n            height: 100%;\n        }\n        .appsManager {\n            background: var(--bg-color);\n            overflow: scroll;\n        }\n        .appContainer {\n            overflow: scroll;\n        }\n        .openClose {\n            display: flex;\n            align-items: center;\n            margin-right: 5px;\n            line-height: 10px;\n            color: #656565;\n            cursor: pointer;\n        }\n        .openClose > .openCloseArrow {\n            width: 10px;\n            height: 10px;\n            background-image: url(\"data:image/svg+xml,%3Csvg fill='%23000000' width='100%' height='100%' version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 407.36 407.36' xml:space='preserve'%3E%3Cg id='SVGRepo_bgCarrier' stroke-width='0'%3E%3C/g%3E%3Cg id='SVGRepo_tracerCarrier' stroke-linecap='round' stroke-linejoin='round'%3E%3C/g%3E%3Cg id='SVGRepo_iconCarrier'%3E%3Cpolygon points='112.814,0 91.566,21.178 273.512,203.718 91.566,386.258 112.814,407.436 315.869,203.718 '%3E%3C/polygon%3E%3C/g%3E%3C/svg%3E\");\n            background-repeat: no-repeat;\n        }\n        .openClose.opened { transform: rotate(90deg); }\n        .opsBtn {\n            cursor: pointer;\n            color: black;\n        }\n\n        .tabs {\n            display: flex;\n            min-height: 30px;\n            background: var(--bg-color);\n            border-bottom: 1px solid lightgray;\n        }\n        .tab {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            column-gap: 5px;\n            padding: 5px 10px;\n            cursor: pointer;\n        }\n        .tab.active { background: #FFFFFF; }\n        .tab.error { background: lightcoral; }\n        .tabHeader {\n            color: black;\n            cursor: pointer;\n            padding: 5px 5px;\n            background: rgb(236, 236, 236);\n            font-weight: bold;\n            gap: 5px;\n        }\n        .tabHeader.active {\n            background: white;\n            color: black;\n        }\n        .tabCloseBtn {\n            margin-left: 5px;\n            width: 0.8em;\n            height: 0.8em;\n            border-radius: 100px;\n            background: rgba(231, 150, 150, 0.99);\n        }\n        .terminal {\n            position: fixed;\n            width: 100%;\n            overflow-x: hidden;\n            overflow-y: scroll;\n            bottom: 0;\n            z-index: 5;\n        }\n        .terminal .scrollContainer {\n            white-space: nowrap;\n        }\n        .consoleCmd {\n            width: 100%;\n            outline: none;\n            border: 1px solid #969696;\n            color: black;\n        }\n\n        .terminal pre {\n            margin: 0;\n            white-space: -moz-pre-wrap; /* Mozilla, supported since 1999 */\n            white-space: -pre-wrap; /* Opera */\n            white-space: -o-pre-wrap; /* Opera */\n            white-space: pre-wrap; /* CSS3 - Text module (Candidate Recommendation) http://www.w3.org/TR/css3-text/#white-space */\n            word-wrap: break-word; /* IE 5.5+ */\n        }\n        .consoleHeader {\n            display: flex;\n            align-items: center;\n            background: #B3E5BE;\n            padding: 0 10px;\n            gap: 10px;\n        }\n        .processLogContent {\n            padding: 0 10px;\n            height: 180px;\n            background: hsl(var(--b2, var(--b1)));\n            overflow: scroll;\n        }\n\n        [contenteditable] {outline: 0; }\n        [contenteditable]:focus {\n            outline: 1px solid #c56565;\n        }\n\n        .shift { margin-left: calc( var(--shift) * 1 ); }\n        .shift1 { margin-left: calc( var(--shift) * 1 ); }\n        .shift2 { margin-left: calc( var(--shift) * 2 ); }\n        .shift3 { margin-left: calc( var(--shift) * 3 ); }\n        .shift4 { margin-left: calc( var(--shift) * 4 ); }\n        .shift5 { margin-left: calc( var(--shift) * 5 ); }\n        .shift6 { margin-left: calc( var(--shift) * 6 ); }\n        .shift7 { margin-left: calc( var(--shift) * 7 ); }\n        .shift8 { margin-left: calc( var(--shift) * 8 ); }\n        .shift9 { margin-left: calc( var(--shift) * 9 ); }\n        .shift10 { margin-left: calc( var(--shift) * 10 ); }\n\n        .authPanel {\n            align-items: center;\n        }\n\n        .monacoEditor {\n            /*position: absolute;*/\n            height: 100%;\n            font-family: 'JetBrains Mono', sans-serif;\n            line-height: 1.55em;\n            font-size: 13.7px;\n            /*min-height: 100vh;*/\n            /*min-width: 50vh;*/\n        }\n        /*.monacoEditor * { font-variant-ligatures : none; }*/\n\n        input {\n            font-family: 'Roboto', sans-serif;\n            font-size: 15px;\n        }\n        input.scriptName {\n            border: 1px solid black;\n            color: black;\n            padding: 3.5px;\n            background: rgb(170 191 222);\n        }\n\n        .hidden { display: none !important; }\n        .visibilityHidden { visibility: hidden; }\n        .grid { display: grid; }\n        .flex { display: flex; }\n        .inlineBlock { display: inline-block; }\n        .gap { gap: 10px; }\n        .alignCenter { align-items: center; }\n        .margin10 { margin-left: 10px; }\n        .cursorPointer { cursor: pointer; }\n\n        .btn {\n            padding: 2px 4px;\n            --tw-bg-opacity: 1;\n            background: hsl(var(--n)/var(--tw-bg-opacity));\n            --tw-text-opacity: 1;\n            color: hsl(var(--nc)/var(--tw-text-opacity));\n            cursor: pointer;\n            text-decoration: none;\n            font-weight: normal;\n            white-space: nowrap;\n        }\n        .btn.white {\n            background: white;\n        }\n        .btn:active {\n            transform: scale(var(--btn-focus-scale,.95));\n        }\n        .btn.hoverGray:hover {\n            background: #d9d9d9;\n        }\n        .burger-btn {\n            display: flex;\n            flex-direction: column;\n            justify-content: space-around;\n            width: 21px;\n            height: 19px;\n            margin: 7px 0 0 7px;\n            border: none;\n            background: transparent;\n            cursor: pointer;\n        }\n        .burger-line {\n            width: 100%;\n            height: 3px;\n            background: #000;\n        }\n        .btnsBar {\n            display: flex;\n            align-items: center;\n            background: #F3F3F3;\n        }\n\n\n        .rotate180 { transform: rotate(180deg); }\n    </style>\n</head>\n<body>\n\n<div id=\"app\"></div>\n<script type=\"text/javascript\" src=\"/node_modules/monaco-editor/min/vs/loader.js\"></script>\n<script>${s['js']}</script>\n</body>\n</html>\n`\n\n    }"},"appContainer":{"js":"async () => {\n    return class AppContainer {\n\n        constructor(app, appPath, dataNode, TabClass, viewClass) {\n            this.id = s.f('sys.uuid');\n            this.app = app;\n            this.appPath = appPath;\n            this.dataNode = dataNode;\n\n            this.v = new viewClass({id: this.id, class: ['appContainer']});\n            e('>', [app.getV(), this.v]);\n\n            let tabName = this.dataNode.getPath().split('.').slice(-2);\n            this.tab = new TabClass(this.id, tabName.join('.'));\n        }\n\n        getId() { return this.id; }\n        getV() { return this.v; }\n\n        // getApp() { return this.app; }\n        // getAppPath() { return this.appPath; }\n        getDataNode() { return this.dataNode; }\n        getTab() { return this.tab; }\n\n        hightLightErr() { this.tab.hightLightErr(); }\n        unHightlightErr() { this.tab.unHightlightErr(); }\n\n        activate() {\n            this.v.show();\n            this.tab.activate();\n            this.app.activate();\n        }\n        deactivate() {\n            this.v.hide();\n            this.tab.deactivate();\n            this.app.deactivate();\n        }\n\n        setWidth(width) { this.v.setStyles({width: width + 'px'}); }\n        setHeight(height) { this.v.setStyles({height: height + 'px'}); }\n\n        onClick(fn) { this.tab.onTabClick(fn); }\n        onClickClose(fn) { this.tab.onTabCloseClick(fn); }\n        close() {\n            this.tab.close();\n            this.app.close();\n        }\n    }\n}"},"appsManager":{"js":"async () => {\n    return class AppsManager {\n\n        async init(localState) {\n            const v = await s.f('sys.ui.view');\n            this.v = new v({class: 'appsManager'});\n\n            this.tabs = new v({class: 'tabs'});\n            e('>', [this.tabs, this.v]);\n\n            this.tabsContentBlock = new v({class: 'tabsContent'});\n            e('>', [this.tabsContentBlock, this.v]);\n\n            this.appsContainers = new Map;\n            this.localState = localState;\n\n\n            const DataNode = await s.f('sys.apps.GUI.dataNode');\n\n            this.openedApps = this.localState.getOpenedApps();\n            for (let i = 0; i < this.openedApps.length; i++) {\n                const [appPath, dataPath] = this.openedApps[i];\n\n                const node = s.find(dataPath);\n                if (!node) {\n                    //todo delete from localState\n                    continue;\n                }\n                const dataNode = new DataNode(node);\n                dataNode.setPath(dataPath);\n\n                await this.openApp(appPath, dataNode, false);\n            }\n        }\n        getTabsHeight() { return this.tabs.getSizes().height; }\n\n        //getTabByContextNode(node) { return this.tabs.get(node.get('id')); }\n        async openApp(appPath, dataNode, addToLocalState = true) {\n\n            if (this.focusedApp) {\n                this.focusedApp.deactivate();\n            }\n\n            const v = await s.f('sys.ui.view');\n            const tabClass = await s.f('sys.apps.GUI.tab');\n\n            //todo check if app is available right now\n            const app = new (await s.f(appPath))(dataNode, v);\n            const appContainerClass = await s.f('sys.apps.GUI.appContainer');\n            const appContainer = new appContainerClass(app, appPath, dataNode, tabClass, v);\n            this.focusedApp = appContainer;\n\n            appContainer.onClick(e => {\n                this.focusApp(appContainer);\n                this.updateFocusedAppContainerDimensions();\n            });\n            appContainer.onClickClose((e, tabIndex) => {\n                e.stopPropagation();\n                this.closeApp(appContainer, tabIndex);\n            });\n            e('>', [appContainer.getTab().getV(), this.tabs]);\n            e('>', [appContainer.getV(), this.tabsContentBlock]);\n            appContainer.activate();\n\n            this.appsContainers.set(appContainer.getId(), appContainer);\n\n            //todo escape dot symbols or just use path as array\n            if (addToLocalState) {\n                this.openedApps.push([ appPath, dataNode.getPath() ]);\n                this.localState.setOpenedApps(this.openedApps);\n            }\n        }\n\n        updateFocusedAppContainerDimensions() {\n            if (!this.focusedApp) return;\n            const {width, height} = e('getDimensionsForAppContainer');\n            this.focusedApp.setWidth(width);\n            this.focusedApp.setHeight(height);\n        }\n\n        focusApp(appContainer) {\n\n            //const nodeId = node.get('id');\n            //const app = this.apps.get(appId);\n            //if (!appId) { console.log('tabId not found', nodeId); return; }\n\n            if (this.focusedApp) {\n                //todo\n                // if (this.activeTab.getContextNodeId() === tab.getContextNodeId()) {\n                //     return;\n                // }\n                this.focusedApp.deactivate();\n            }\n            this.focusedApp = appContainer;\n            appContainer.activate();\n\n            //this.localState.s(appContainer.getId());\n        }\n\n        closeApp(appContainer, tabIndex) {\n\n            //const isActiveTab = this.activeTab && this.activeTab.getContextNodeId() === contextUnitId;\n            // if (isActiveTab) {\n            //     for (let [_, tab] of this.tabs) {\n            //         if (tab.getContextNodeId() === contextUnitId) continue;\n            //         this.focusTab(tab.getContextNode());\n            //         break;\n            //     }\n            // }\n            this.appsContainers.delete(appContainer.getId());\n            appContainer.close();\n\n            if (tabIndex !== undefined) {\n                this.openedApps.splice(tabIndex, 1);\n                this.localState.setOpenedApps(this.openedApps);\n            }\n            //todo switch to closest opened tab\n        }\n\n        async onKeyDown(e) {\n            // if (this.activeTab && this.activeTab.getApp().onKeyDown) {\n            //     this.activeTab.getEditor().onKeyDown(e);\n            // }\n        }\n        async onClick(e) {\n            // if (this.activeTab && this.activeTab.getEditor().onClick) {\n            //     this.activeTab.getEditor().onClick(e);\n            // }\n        }\n        getFocusedApp() { return this.focusedApp; }\n        getV() { return this.v }\n        setHeight(height) {\n            const tabsHeight = this.tabs.getSizes().height;\n            if (this.focusedApp) {\n                this.focusedApp.setHeight(height - tabsHeight);\n            }\n        }\n        setWidth(width) {\n            //this.getV().setStyles({height: height + 'px'});\n            if (this.focusedApp) this.focusedApp.setWidth(width);\n        }\n    }\n}"},"outliner":{"js":"async () => {\n\n    return class Outliner {\n\n        getV() { return this.v; }\n\n        async init(localState, input) {\n            this.input = input;\n            this.http = new (await s.f('sys.httpClient'));\n            this.nodes = new Map;\n\n            const v = await s.f('sys.ui.view');\n            this.v = new v({class: 'outliner'});\n\n            const header = new v({txt: 'Data Browser', class: 'outlinerHeader'});\n            e('>', [header, this.v]);\n\n            const OutlinerNode = await s.f('sys.apps.GUI.outlinerNode');\n            this.outlinerNode = OutlinerNode;\n            const DataNode = await s.f('sys.apps.GUI.dataNode');\n            this.node = DataNode;\n\n            const rootDataNode = new DataNode(s);\n            const rootOutlinerNode = new OutlinerNode;\n            await rootOutlinerNode.init(rootDataNode, true);\n            rootOutlinerNode.removeSubNodesShift();\n            e('>', [rootOutlinerNode, this.v]);\n\n            s.e('outlinerNode.ui.add', {outlinerNode: rootOutlinerNode});\n\n            this.localState = localState;\n            this.openedPaths = this.localState.getOpenedPaths();\n            if (!this.openedPaths) this.openedPaths = {};\n\n            //todo clear this.openedPaths which not exists in \"s\"\n            await rootOutlinerNode.open(this.openedPaths);\n\n            this.buffer = null;\n        }\n\n        setHeight(height) { this.getV().setStyles({height: height + 'px'}); }\n        //todo put outliner content in container without padding and remove this shit\n        getWidth() { return this.getV().getSizes().width; }\n        getHorizontalPadding() {\n            return parseInt(this.getV().getComputedStyle('padding-left').slice(0, -2), 10) * 2;\n        }\n        //isEmpty() { return this.outLinerRootNode.isEmpty()}\n        getOutlinerNodeById(id) { return this.nodes.get(id); }\n\n        async duplicate(outlinerNode) {\n\n            const parentDataNode = outlinerNode.getParent().getDataNode();\n            const dataNode = outlinerNode.getDataNode();\n            const newK = dataNode.getKey() + '_copy';\n\n            if (parentDataNode.get(newK)) {\n                console.log(`Key ${newK} already exists in object.`); return;\n            }\n            let v = dataNode.getData();\n            if (s.f('sys.isObject', v) || s.f('sys.isArray', v)) v = structuredClone(v);\n\n            const newDataNode = new this.node(v);\n            newDataNode.setKey(newK);\n            const newOutlinerNode = new this.outlinerNode;\n            await newOutlinerNode.init(newDataNode, false);\n\n            e('>after', [newOutlinerNode.getV(), outlinerNode.getV()]);\n            this.nodes.set(newOutlinerNode.getDomId(), newOutlinerNode);\n\n            parentDataNode.set(newK, v);\n            setTimeout(() => newOutlinerNode.focus(), 100);\n\n            newDataNode.setPath(newOutlinerNode.getPath());\n            s.e('state.update', {dataNode: newDataNode, data: v});\n        }\n\n        async handleKeyDown(e) {\n\n            if (!e.target.classList.contains('dataKey')) return;\n\n            const outlinerNode = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n            if (!outlinerNode) { console.log('outlinerNode not found'); return; }\n\n            const k = e.key;\n            const ctrl = e.ctrlKey || e.metaKey;\n\n            if (k === 'Enter') {\n                e.preventDefault();\n            } else if (k === 'Tab') {\n                e.preventDefault();\n                // if (e.shiftKey) {\n                //     const parent = outlinerNode.getParent();\n                //     window.e('>after', [outlinerNode.getV(), parent.getV()]);\n                // } else if (outlinerNode.prev()) {\n                //     window.e('>', [outlinerNode.getV(), outlinerNode.prev().getNodesV()]);\n                // }\n\n            } /*else if (ctrl && k === 'ArrowUp' && outlinerNode.prev()) {\n                window.e('>after', [outlinerNode.prev().getV(), outlinerNode.getV()]);\n            } else if (ctrl && k === 'ArrowDown' && outlinerNode.next()) {\n                window.e('>after', [outlinerNode.getV(), outlinerNode.next().getV()]);\n            } */else if (ctrl && k === 'v') {\n                //setTimeout(() => {\n                    //outlinerNode.updateNameInContextNode();\n                    //this.save();\n                //}, 200);\n                return;\n            } else {\n                return;\n            }\n            e.target.focus();\n            //await this.save();\n        }\n\n        async handleKeyUp(e) {\n\n            if (!e.target.classList.contains('dataKey')) return;\n\n            const ignoreKeys = ['Enter', 'Tab', 'Control', 'Meta', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];\n            if (new Set(ignoreKeys).has(e.key)) return;\n\n            const outlinerNode = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n\n            const node = outlinerNode.getDataNode();\n            const newK = e.target.innerText;\n            const v = node.getData();\n\n            if (newK.length === 0) {\n                if (!confirm('Delete object?')) return;\n                s.e('state.del', {outlinerNode})\n                return;\n            }\n\n            const oldKPath = outlinerNode.getPath();\n            const newKPath = [...oldKPath];\n            newKPath[newKPath.length - 1] = newK;\n\n            if (newKPath.toString() === oldKPath.toString()) return;\n\n            await this.http.post('/stateUpdate', { cmds: [{newPath: newKPath, oldPath: oldKPath, op: 'mv'}] });\n            const parentDataNode = outlinerNode.getParent().getDataNode();\n\n            parentDataNode.set(newKPath.at(-1), v);\n            parentDataNode.del(oldKPath.at(-1));\n\n            node.setKey(newK);\n        }\n\n        async handleClick(e) {\n            const addOpenedNode = node => {\n                //todo some func to direct iteration in depth of object by path\n                let lastObj = this.openedPaths;\n                const path = node.getPath();\n\n                for (let i = 0; i < path.length; i++) {\n                    const pathPart = path[i];\n                    if (!lastObj[pathPart]) lastObj[pathPart] = {};\n                    lastObj = lastObj[pathPart];\n                }\n                this.localState.setOpenedPaths(this.openedPaths);\n            }\n            const deleteOpenedNode = node => {\n\n                let lastObj = this.openedPaths;\n                let lastPart;\n                const path = node.getPath();\n\n                for (let i = 0; i < path.length; i++) {\n                    const part = path[i];\n                    const isLastIndex = i === path.length - 1;\n                    if (isLastIndex) {\n                        delete lastObj[part];\n                        break;\n                    }\n                    lastObj = lastObj[part];\n                    lastPart = part;\n                }\n                this.localState.setOpenedPaths(this.openedPaths);\n            }\n            const classList = e.target.classList;\n\n            if (classList.contains('openClose') || classList.contains('openCloseArrow')) {\n\n                let outlinerNode = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n                if (!outlinerNode.hasSomethingToOpen()) {\n                    return;\n                }\n                if (outlinerNode.isOpened) {\n                    outlinerNode.close()\n                    deleteOpenedNode(outlinerNode);\n                } else {\n                    outlinerNode.open();\n                    addOpenedNode(outlinerNode);\n                }\n                return;\n            }\n\n            if (classList.contains('dataKey')) {\n\n                let node = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n                if (!node.hasSomethingToOpen()) return;\n                if (!node.isOpened) {\n                    node.open();\n                    addOpenedNode(node);\n                }\n            }\n        }\n\n        async handleDblClick(e) {\n            if (!e.target.classList.contains('dataKey') && !e.target.classList.contains('dataValue')) {\n                return;\n            }\n            //let outlinerNode = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n            //window.e('openNode', {outlinerNode});\n        }\n\n        handleContextMenu(e) {\n            e.preventDefault();\n\n            const isDataK = e.target.classList.contains('dataKey');\n            const isDataV = e.target.classList.contains('dataValue');\n            if (!isDataK && !isDataV) return;\n\n            const outlinerNode = this.getOutlinerNodeById(e.target.getAttribute('outliner_node_id'));\n            const dataNode = outlinerNode.getDataNode();\n            const data = dataNode.getData();\n\n            const v = s.f('sys.ui.view');\n            const createBtn = (txt) => {\n                return new v({ txt, class: ['btn', 'contextMenu', 'white', 'hoverGray'] });\n            }\n\n            const popup = s.sys.popup;\n            let submenu;\n            const removeSubmenu = () => {\n                if (!submenu) return;\n                submenu.clear();\n                submenu = null;\n            }\n\n            let oBtn = createBtn('Open with');\n            let openWithBtn = oBtn;\n            oBtn.on('pointerenter', async () => {\n                removeSubmenu();\n                submenu = new (s.f('sys.apps.GUI.popup'));\n                window.e('app.addViewElement', submenu);\n\n                const apps = s.sys.apps;\n                //todo const authorizedUserApps = s.users[user].apps;\n\n                for (let name in apps) {\n                    if (name === 'GUI') continue;\n                    let appBtn = createBtn(name);\n                    appBtn.on('click', () => {\n                        window.e('openNode', {appPath: `sys.apps.${name}`, outlinerNode});\n                        popup.clear();\n                    });\n                    window.e('>', [appBtn, submenu]);\n                }\n                submenu.putRightTo(openWithBtn);\n            });\n            window.e('>', [oBtn, popup]);\n\n\n            if (typeof data === 'object' && data !== null) {\n                oBtn = createBtn('Add item');\n                oBtn.on('pointerenter', removeSubmenu);\n                oBtn.on('click', () => {\n\n                    if (Array.isArray(data)) {\n                        data.push('item' + data.length + 1);\n                    } else {\n                        let c = 0;\n                        while (1) {\n                            c++;\n                            const k = 'newKey' + c; const v = 'newValue';\n                            if (data[k]) continue;\n\n                            data[k] = v;\n                            const dataNode = new this.node;\n                            dataNode.setPath([...outlinerNode.getPath(), k]);\n                            s.e('state.update', {dataNode, data: v});\n                            break;\n                        }\n                    }\n\n                    outlinerNode.reopen();\n                    popup.clear();\n                });\n                window.e('>', [oBtn, popup]);\n            }\n\n            oBtn = createBtn('Copy');\n            oBtn.on('click', () => {\n                this.buffer = {mode: 'copy', outlinerNode};\n                popup.clear();\n            });\n            oBtn.on('pointerenter', removeSubmenu);\n            window.e('>', [oBtn, popup]);\n\n            oBtn = createBtn('Cut');\n            oBtn.on('click', () => {\n                this.buffer = {mode: 'cut', outlinerNode};\n                popup.clear();\n            });\n            oBtn.on('pointerenter', removeSubmenu);\n            window.e('>', [oBtn, popup]);\n\n            if (this.buffer) {\n                oBtn = createBtn('Paste');\n                oBtn.on('click', async () => {\n                    if (!this.buffer) return;\n\n                    const contextNodeData = outlinerNode.getDataNode().getData();\n                    if (!s.f('sys.isObject', contextNodeData) && !Array.isArray(contextNodeData)) return;\n\n                    const bufOurlinerNode = this.buffer.outlinerNode;\n                    const dataPath = bufOurlinerNode.getPath();\n\n                    const dataNodeCopy = new this.node;\n                    //todo in case of array we don't need to set key. just push to array\n                    dataNodeCopy.setPath([...outlinerNode.getPath(), dataPath.at(-1)]);\n\n                    const data = structuredClone(bufOurlinerNode.getDataNode().getData());\n                    s.e('state.update', {dataNode: dataNodeCopy, data});\n                    if (this.buffer.mode === 'cut') {\n                        await s.e('state.del', {outlinerNode: bufOurlinerNode});\n                    }\n\n                    this.buffer = null;\n                    outlinerNode.reopen(); //todo remember opened nodes\n                    popup.clear();\n                });\n                oBtn.on('pointerenter', removeSubmenu);\n                window.e('>', [oBtn, popup]);\n            }\n\n            oBtn = createBtn('Duplicate');\n            oBtn.on('click', async () => {\n                await this.duplicate(outlinerNode);\n                popup.clear();\n            });\n            oBtn.on('pointerenter', removeSubmenu);\n            window.e('>', [oBtn, popup]);\n\n            oBtn = createBtn('Console log');\n            oBtn.on('pointerenter', removeSubmenu);\n            oBtn.on('click', () => {\n                s.l(dataNode);\n                popup.clear();\n            });\n            window.e('>', [oBtn, popup]);\n\n            oBtn = createBtn('Console path');\n            oBtn.on('pointerenter', removeSubmenu);\n            oBtn.on('click', () => {\n                s.l(outlinerNode.getPath());\n                popup.clear();\n            });\n            window.e('>', [oBtn, popup]);\n\n            oBtn = createBtn('Convert type to');\n            let convertTypeBtn = oBtn;\n            oBtn.on('pointerenter', () => {\n                removeSubmenu();\n                submenu = new (s.f('sys.apps.GUI.popup'));\n                window.e('app.addViewElement', submenu);\n\n                const types = ['Object', 'Array', 'String'];\n                types.forEach(type => {\n                    let btn = createBtn(type);\n                    btn.on('click', () => {\n                        let data;\n                        if (type === 'Array') data = [];\n                        if (type === 'Object') data = {};\n                        if (type === 'String') data = 'str';\n                        if (data === undefined) return;\n                        s.e('state.update', {outlinerNode, data});\n\n                        outlinerNode.getParent().reopen();\n                        popup.clear();\n                    });\n                    window.e('>', [btn, submenu]);\n                });\n                submenu.putRightTo(convertTypeBtn);\n\n            });\n            window.e('>', [oBtn, popup]);\n\n            popup.onClear(() => removeSubmenu());\n            popup.putRightToPointer({x: e.clientX, y: e.clientY});\n        }\n\n    }\n}"},"outlinerNode":{"js":"async () => {\n\n    return class OutlinerNode {\n\n        async init(dataNode, isRoot) {\n            this.dataNode = dataNode;\n            this.domId = s.f('sys.uuid');\n\n            const v = await s.f('sys.ui.view');\n            this.v = new v({id: this.domId, class: ['node']});\n            this.isOpened = false;\n            this.isRoot = isRoot;\n\n            if (!this.isRoot) await this.createDataFields(dataNode);\n\n            this.subNodesV = new v({class: ['subNodes', 'shift']});\n            e('>', [this.subNodesV, this.v]);\n        }\n        getId() { return this.domId; }\n\n        async createDataFields(dataNode) {\n            const data = dataNode.getData();\n            let dType = dataNode.getDataType();\n            let dTypeLabel = {boolean: 'bool', function: 'f', number: 'num',  object: ''}[dType] ?? dType;\n            if (data === null) dTypeLabel = 'null';\n            else if (data === undefined) dTypeLabel = 'undefined';\n\n            const v = await s.f('sys.ui.view');\n            const container = new v({class: ['nodeContainer', 'flex']}); e('>', [container, this.v]);\n\n            this.openClose = new v({class: 'openClose'});\n            this.openClose.setAttr('outliner_node_id', this.domId);\n            e('>', [this.openClose, container]);\n\n            const openCloseArrow = new v({class: 'openCloseArrow'});\n            openCloseArrow.setAttr('outliner_node_id', this.domId);\n            e('>', [openCloseArrow, this.openClose]);\n            if (!this.hasSomethingToOpen()) this.openCloseBtnHide();\n\n            this.keyV = new v({class: 'dataKey', txt: dataNode.getKey()});\n            this.keyV.setAttr('outliner_node_id', this.domId);\n            this.keyV.toggleEdit();\n            e('>', [this.keyV, container]);\n\n            if (!s.f('sys.isObject', data) && !Array.isArray(data)) {\n                e('>', [new v({class: 'sep', txt: ':', style: {marginRight: '5px'}}), container]);\n            }\n\n            let slicedStrInfo;\n            let opsBtn;\n            const createValueV = (txt, className, color) => {\n                if (txt === false) txt = 'false';\n\n                return new v({txt, class: className, style: {color: color, whiteSpace: 'nowrap'}});\n            }\n\n            let valueV;\n\n            if (dType === 'boolean') {\n                valueV = createValueV(data, 'dataValue',  'blue');\n                valueV.iEditMod();\n            } else if (dType === 'number') {\n                valueV = createValueV(data, 'dataValue', '#221199');\n                valueV.iEditMod();\n            } else if (dType === 'string') {\n\n                const limit = 500;\n                let isSliced = false;\n                let str = data;\n                if (str.length > limit) {\n                    str = str.slice(0, limit).trim() + '...';\n                    str = str.replaceAll('\\n', '');\n                    isSliced = true;\n                }\n                valueV = createValueV(str, ['dataValue', 'string'], '#AA1011');\n                if (isSliced) {\n                    slicedStrInfo = new v({txt: 'and more ' + (data.length - limit) + ' chars', style: {marginLeft: '5px', 'white-space': 'nowrap'}});\n                } else {\n                    valueV.iEditMod();\n                }\n\n            } else {\n                valueV = createValueV(dTypeLabel, 'dataType', 'gray')\n            }\n            valueV.setAttr('outliner_node_id', this.domId);\n            valueV.on('keyup', async () => this.netUpdate());\n\n\n            if (dType === 'string') e('>', [new v({class: 'quote', txt: \"'\"}), container]);\n            e('>', [valueV, container]);\n            if (dType === 'string') e('>', [new v({class: 'quote', txt: \"'\"}), container]);\n\n            if (slicedStrInfo) e('>', [slicedStrInfo, container]);\n            if (opsBtn) e('>', [opsBtn, container]);\n\n            this.valueV = valueV;\n        }\n\n        async netUpdate() {\n            const v = this.valueV.getTxt();\n            if (!v) {\n                if (confirm('Delete prop?')) {\n                    s.e('state.del', {outlinerNode: this});\n                }\n                return;\n            }\n            if (v === this.getDataNode().getData()) return;\n\n            s.e('state.update', {outlinerNode: this, data: v});\n        }\n        getDomId() { return this.domId }\n\n        async requestData() {\n            const http = new (await s.f('sys.httpClient'));\n            const {data} = await http.post('/state', {path: this.getPath()});\n            if (data) {\n                this.dataNode.setData(data);\n                const parentNode = s.find(this.getPath().slice(0, -1));\n                if (parentNode) {\n                    parentNode[this.getPath().at(-1)] = data;\n                }\n            } else {\n                this.dataNode.getData()[s.sys.SYMBOL_IS_EMPTY_NODE] = true;\n            }\n        }\n\n        async open(openedPaths = {}) {\n\n            const dType = this.dataNode.getDataType();\n            let v = this.dataNode.getData();\n            if (dType !== 'object' || v === null) return;\n\n            if (s.f('sys.isEmptyObject', v) || (Array.isArray(v) && v.length === 0)) {\n\n                if (!v[s.sys.SYMBOL_IS_EMPTY_NODE]) await this.requestData();\n                //todo add global method, getParentNode\n            }\n\n            v = this.dataNode.getData();\n\n            const NodeClass = await s.f('sys.apps.GUI.dataNode');\n            const OutlinerNodeClass = await s.f('sys.apps.GUI.outlinerNode');\n\n            const renderNode = async (k, node) => {\n                const dataNode = new NodeClass(node);\n                dataNode.setKey(k);\n\n                const outlinerNode = new OutlinerNodeClass;\n                await outlinerNode.init(dataNode, false);\n                e('>', [outlinerNode.getV(), this.getNodesV()]);\n                s.e('outlinerNode.ui.add', {outlinerNode});\n\n                if (openedPaths[k] && outlinerNode.hasSomethingToOpen()) {\n                    await outlinerNode.open(openedPaths[k]);\n                }\n            }\n\n            if (Array.isArray(v)) {\n                for (let i = 0; i < v.length; i++) await renderNode(i, v[i]);\n            } else {\n                const nameNode = {};\n                for (let k in v) {\n                    const kLower = k.toLowerCase();\n                    if (!nameNode[kLower]) nameNode[kLower] = [];\n                    nameNode[kLower].push({ k, node: v[k] });\n                }\n                const sortedKeys = Object.keys(nameNode).sort();\n                for (let i = 0; i < sortedKeys.length; i++) {\n\n                    const nodes = nameNode[ sortedKeys[i] ];\n                    for (let j = 0; j < nodes.length; j++) {\n                        await renderNode(nodes[j].k, nodes[j].node);\n                    }\n                }\n            }\n            this.isOpened = true;\n            if (this.openClose) this.openClose.addClass('opened');\n        }\n        async close() {\n            const nodesV = this.getNodesV();\n            const children = nodesV.getChildren();\n            //todo should be recursive\n            for (let i = 0; i < children.length; i++) {\n                const id = children[i].id;\n                if (!id) throw Error('no outliner_node_id on ' + children[i]);\n                s.e('outlinerNode.ui.remove', id);\n            }\n            nodesV.clear();\n            this.isOpened = false;\n            if (!this.isRoot) {\n                this.openClose.removeClass('opened');\n            }\n        }\n\n        reopen() {\n            //todo close all items recursive and open again\n            if (this.isOpened) this.close();\n            this.open();\n        }\n\n        hasSomethingToOpen() {\n            const data = this.getDataNode().getData();\n            const dType = this.getDataNode().getDataType();\n\n            if (dType !== 'object' || data === null) return false;\n\n            return true;\n            //if (Array.isArray(data)) return data.length > 0;\n            //return !s.f('sys.isEmptyObject', data);\n        }\n\n        async showOutlinerOpsPopup(opsBtn) {\n            s.popup.clear();\n\n            const v = await s.f('sys.ui.view');\n\n            const createBtn = txt => new v({txt, class: 'btn'});\n\n            let oBtn = createBtn('Add');\n            oBtn.on('click', async () => {\n                this.getDataNode().set('newProp', 'value');\n                this.openClose.visibilityShow();\n                await this.close();\n                await this.open();\n                s.popup.clear();\n            });\n            e('>', [oBtn, s.popup]);\n\n            // oBtn = createBtn('delete'); oBtn.on('click', e => {\n            //     if (confirm('Delete prop?')) {\n            //         s.e('state.del', {outlinerNode: this});\n            //     }\n            //     s.popup.clear();\n            // });\n            // e('>', [oBtn, s.popup]);\n\n            // oBtn = createBtn('console.log'); oBtn.on('click', e => {\n            //     console.log(this.getDataNode());\n            //     s.popup.clear();\n            // });\n            e('>', [oBtn, s.popup]);\n\n            s.popup.putRightTo(opsBtn);\n        }\n        openCloseBtnShow() { this.openClose.visibilityShow(); }\n        openCloseBtnHide() { this.openClose.visibilityHide(); }\n\n        //isEmpty() { return !this.dataNodesV.getDOM().children.length }\n        isInRoot() { return this.getParent().isRoot }\n        getParent() {\n            return s.e('outlinerNode.find', this.v.parentDOM().parentNode.id);\n        }\n        getPath() {\n            let path = [];\n            let lastNode = this;\n            while (!lastNode.isRoot) {\n                path.push(lastNode.getDataNode().getKey());\n                lastNode = lastNode.getParent();\n            }\n            return path.reverse();\n        }\n\n        // next() {\n        //     const next = this.v.getDOM().nextSibling;\n        //     return next ? s.outlinerPool.get(next.id) : null;\n        // }\n        // prev() {\n        //     const previous = this.v.getDOM().previousSibling;\n        //     return previous ? s.outlinerPool.get(previous.id) : null;\n        // }\n        getDataNode() { return this.dataNode }\n\n        getV() { return this.v }\n        getKeyValue() { return this.keyV.getTxt(); }\n\n        getNodesV() { return this.subNodesV }\n        removeSubNodesShift() { this.subNodesV.removeClass('shift'); }\n        focus() { this.keyV.focus(); }\n        remove() { this.getV().removeFromDom(); }\n    }\n}"},"localState":{"js":"async () => {\n    return class LocalState {\n\n        constructor() {\n            const openedAppsJSON = localStorage.getItem('openedApps');\n            this.openedApps = openedAppsJSON ? JSON.parse(openedAppsJSON) : {};\n        }\n        setOpenedApps(openedApps) {\n            localStorage.setItem('openedApps', JSON.stringify(openedApps));\n        }\n        getOpenedApps() {\n            const str = localStorage.getItem('openedApps');\n            if (str) return JSON.parse(str);\n            return [];\n        }\n        setOpenedPaths(openedPaths) {\n            localStorage.setItem('openedPaths', JSON.stringify(openedPaths));\n        }\n        getOpenedPaths() {\n            const str = localStorage.getItem('openedPaths');\n            if (str) return JSON.parse(str);\n            return {};\n        }\n\n        setActiveTabId(tabId) { localStorage.setItem('activeTabId', tabId); }\n        getActiveTabId() { return localStorage.getItem('activeTabId'); }\n\n        setOutlinerWidth(v) { localStorage.setItem('outlinerWidth', v); }\n        getOutlinerWidth() { return localStorage.getItem('outlinerWidth'); }\n\n        getLogPanelHeight() { return localStorage.getItem('logPanelHeight'); }\n        setLogPanelHeight(v) { localStorage.setItem('logPanelHeight', v); }\n\n        get(k) { return localStorage.getItem(k); }\n        set(k, v) { localStorage.setItem(k, v); }\n        del(k) { localStorage.removeItem(k); }\n    }\n    \n}"},"dataNode":{"js":"async () => {\n    return class DataNode {\n        constructor(data) { this.data = data }\n        setKey(key) { this.key = key }\n        getKey() { return this.key }\n\n        getPath() { return this.path; }\n        setPath(path) { this.path = path; }\n\n        getData() { return this.data }\n        setData(data) { this.data = data; }\n\n        getDataType() { return typeof this.data }\n        get(k) { return this.data[k] }\n        set(k, v) { this.data[k] = v }\n        del(k) { delete this.data[k] }\n        isEmpty() {\n            return Object.keys(this.data).length === 0;\n        }\n    }\n}"},"tab":{"js":"async () => {\n    return class TabName {\n        constructor(tabId, name) {\n\n            const v = s.f('sys.ui.view');\n            this.v = new v({id: tabId, class: 'tab'});\n\n            this.name = new v({class: 'tabName', txt: name});\n            e('>', [this.name, this.v]);\n            this.closeBtn = new v({class: 'tabCloseBtn'});\n            e('>', [this.closeBtn, this.v]);\n\n        }\n        hightLightErr() { this.v.addClass('error'); }\n        unHightlightErr() { this.v.removeClass('error'); }\n\n        getOutlinerNode() { return this.outlinerNode; }\n        activate() { this.v.addClass('active'); }\n        deactivate() { this.v.removeClass('active'); }\n        onTabClick(fn) { this.v.on('click', e => fn(e)); }\n        onTabCloseClick(fn) {\n            this.closeBtn.on('click', e => {\n                fn(e, this.closeBtn.parent().getDOMIndex());\n            });\n        }\n        close() { this.v.removeFromDom(); }\n        getV() { return this.v; }\n    }\n}"},"popup":{"js":"() => {\n    return class popup {\n\n        constructor() {\n            const v = s.f('sys.ui.view');\n            this.v = new v({class: 'popup'});\n        }\n        clear() {\n            this.v.clear();\n            if (this.clearCallback) this.clearCallback();\n            this.clearCallback = null;\n        }\n        remove() { this.v.remove(); }\n        onClear(cb) { this.clearCallback = cb; }\n\n        setDimensions(width, height) {\n            this.v.setStyles({\n                width: width + 'px',\n                height: height + 'px',\n            });\n        }\n\n        putRightTo(v) {\n            const sizes = v.getSizesAbsolute();\n            this.v.setStyles({top: sizes.top + 'px', left: sizes.right + 'px'});\n        }\n        putRightToPointer(pointer) {\n            //todo scroll?\n            this.v.setStyles({left: pointer.x + 8 + 'px', top: pointer.y + 'px'});\n        }\n        getV() { return this.v; }\n    }\n\n}"},"terminal":{"js":"async () => {\n    return class Terminal {\n\n        constructor(localState, input) {\n            const v = s.f('sys.ui.view');\n\n            this.v = new v({class: 'terminal'});\n            this.header = new v({class: 'consoleHeader'});\n            e('>', [this.header, this.v]);\n            \n            e('>', [new v({txt: 'Terminal', style: {fontWeight: 'bold'}}), this.header]);\n\n            const clear = new v({txt: 'clear', class: ['btn', 'cursorPointer']});\n            clear.on('click', e => this.content.clear());\n            e('>', [clear, this.header]);\n\n            const scrollContainer = new v({class: ['scrollContainer', 'flex']});\n            e('>', [scrollContainer, this.header]);\n\n            this.automaticScroll = new v({tagName: 'input'});\n            this.automaticScroll.setAttr('type', 'checkbox');\n            this.automaticScroll.setAttr('checked', 'true');\n\n            e('>', [this.automaticScroll, scrollContainer]);\n            e('>', [new v({txt: 'automatic scroll'}), scrollContainer]);\n\n            //const http = new (s.f('sys.httpClient'));\n            // const file = new v({tagName: 'input'});\n            // file.setAttr('type', 'file');\n            // e('>', [file, this.header]);\n            // file.on('change', e => {\n            //     const reader = new FileReader;\n            //     reader.onload = async () => {\n            //         s.l(await http.postBuf('/uploadFile', reader.result));\n            //     }\n            //     reader.readAsArrayBuffer(file.getDOM().files[0]);\n            // });\n\n            const cmds = {\n                outlinerHide: () => {\n                    //\n                }\n            };\n            const consoleCmd = new v({tagName: 'input', class: ['nooutline', 'consoleCmd']});\n            this.consoleCmd = consoleCmd;\n            consoleCmd.setAttr('placeholder', 'cmd');\n            consoleCmd.on('keydown', (e) => {\n                if (e.key !== 'Enter') return;\n                const v = e.target.value;\n\n                //autocomplete for commands\n                if (v === 'outliner.hide') {\n                    localState.set('outlinerHidden', 1);\n                    //outliner hide\n                }\n                if (v === 'outliner.show') {\n                    localState.del('outlinerHidden');\n                }\n            });\n            consoleCmd.on('keyup', (e) => {\n\n            });\n            e('>', [consoleCmd, this.v]);\n\n            this.content = new v({class: 'processLogContent'});\n            e('>', [this.content, this.v]);\n\n            const height = Number(localState.getLogPanelHeight());\n            if (height && height < window.innerHeight) {\n                this.content.setStyles({height: height + 'px'});\n            } else {\n                this.content.setStyles({height: '100px'});\n                localState.setLogPanelHeight(100);\n            }\n\n            this.input = input;\n            this.localState = localState;\n\n            this.dragAndDrop();\n        }\n\n        init() { e('terminalSizeChanged', this.v.getSizes().height); }\n        getHeight() { return this.v.getSizes().height; }\n\n        dragAndDrop() {\n            let headerSizes;\n            let consoleCmdSizes;\n            let shift;\n\n            const pointerMove = (e) => {\n                const mouseY = e.clientY;\n                if (mouseY < headerSizes.height) {\n                    this.content.setStyles({height: window.innerHeight - headerSizes.height - consoleCmdSizes.height + 'px'});\n                    return;\n                }\n                const contentHeight = window.innerHeight - mouseY - headerSizes.height - consoleCmdSizes.height + shift;\n                this.content.setStyles({height: contentHeight + 'px'});\n\n                window.e('terminalSizeChanged');\n            }\n            this.header.on('pointerdown', (e) => {\n                e.preventDefault();\n                headerSizes = this.header.getSizes();\n                consoleCmdSizes = this.consoleCmd.getSizes();\n                shift = e.clientY - headerSizes.y;\n\n                this.input.onMouseMove(pointerMove);\n                this.input.onMouseUp(() => {\n                    this.input.onMouseUp(null);\n                    this.input.onMouseMove(null);\n                    this.localState.setLogPanelHeight(this.content.getSizes().height);\n                });\n            });\n        }\n\n        getV() { return this.v; }\n        show() {\n            this.v.show();\n        }\n        hide() {\n            this.v.hide();\n            window.e('terminalSizeChanged');\n        }\n        switchVisibility() { this.v.isShowed() ? this.v.hide() : this.v.show(); }\n\n        addMsg() {\n\n\n        }\n\n        enableAutomaticScroll() { this.automaticScroll.setAttr('checked', ''); }\n}\n    \n}"},"authBar":{"js":"() => {\n\n    return class AuthBar {\n\n        init(v, http) {\n            const authPanel = new v({class: ['flex', 'authPanel']});\n            //this.v.attachShadow();\n\n            const tokenInput = new v({tagName: 'input', txt: 'clear', class: ['tokenInput']});\n            tokenInput.setAttr('placeholder', 'token');\n            tokenInput.setAttr('type', 'password');\n            e('>', [tokenInput, authPanel]);\n            tokenInput.on('pointerdown', e => {\n                e.stopPropagation();\n            });\n            const signIn = new v({txt: 'Sign In', class: ['btn', 'cursorPointer']});\n            signIn.on('click', async e => {\n                e.stopPropagation();\n                const token = tokenInput.getVal().trim();\n                if (!token) return;\n                const r = await http.post('/sign/in', {token: token});\n                s.l(r);\n            });\n            signIn.on('contextmenu', e => e.stopPropagation());\n            e('>', [signIn, authPanel]);\n\n            const signOut = new v({txt: 'Sign Out', class: ['btn', 'cursorPointer']});\n            signOut.on('click', e => {\n                e.stopPropagation();\n                http.post('/sign/out');\n            });\n            signOut.on('contextmenu', e => e.stopPropagation());\n            e('>', [signOut, authPanel]);\n\n            this.v = authPanel;\n        }\n        \n        getV() { return this.v }\n        getKeyValue() { return this.keyV.getTxt(); }\n        getHeight() { return this.v.getSizes().height; }\n\n\n        getNodesV() { return this.subNodesV }\n        removeSubNodesShift() { this.subNodesV.removeClass('shift'); }\n        focus() { this.keyV.focus(); }\n        remove() { this.getV().removeFromDom(); }\n    }\n}"}},"monacoEditor":{"js":"async () => {\n    return class MonacoEditor {\n\n        constructor(dataNode, v) {\n            this.dataNode = dataNode;\n            this.v = new v({ class:['monacoEditor']});\n            this.isEditorInitiated = false;\n        }\n\n        activate() {\n            this.show();\n\n            if (this.isEditorInitiated) return;\n            this.isEditorInitiated = true;\n\n            // this.editor = ace.edit(this.v.getDOM(), {mode: 'ace/mode/javascript', selectionStyle: 'text'});\n            // this.editor.setTheme('ace/theme/iplastic');\n            // this.editor.session.on('changeMode', (e, session) => {\n            //     if (\"ace/mode/javascript\" === session.getMode().$id) {\n            //         if (!!session.$worker) {\n            //             session.$worker.send(\"setOptions\", [{\"esversion\": 9, \"esnext\": false}]);\n            //         }\n            //     }\n            // });\n            // this.editor.session.setUseWorker(false);\n            // this.editor.session.setMode('ace/mode/javascript');\n            // this.editor.setValue(this.outlinerNode.getContextNode().getData(), 1);\n            //this.editor.destroy();\n\n            this.editor = monaco.editor.create(this.v.getDOM(), {\n                value: this.dataNode.getData(),\n                automaticLayout: true,\n                language: 'javascript', fontSize: '14px', theme: 'vs-light',\n            });\n            //this.editor.layout();\n            this.editor.getModel().onDidChangeContent(async e => {\n                const value = this.editor.getValue();\n                // try { eval(js); s.e('JsEvalResult', {error: 0}); }\n                // catch (e) { s.e('JsEvalResult', {error: e}); }\n\n                s.e('state.update', {dataNode: this.dataNode, data: value});\n            });\n        }\n        deactivate() {\n            this.hide();\n        }\n\n        getV() { return this.v; }\n        show() { this.v.show(); }\n        hide() { this.v.hide(); }\n        close() { this.v.removeFromDom(); }\n    }\n}","gender":"okok"},"txtEditor":{"js":"async () => {\n    return class TxtEditor {\n\n        constructor(dataNode, v, vContainer) {\n\n            this.dataNode = dataNode;\n            this.v = new v({style: {height: '100%'}});\n            this.v.attachShadow();\n\n            const css = new v({tagName: 'style'});\n            css.setHtml(`\ntextarea {\n    font-family: 'Roboto', sans-serif;\n    width: 99%;\n    height: 99%;\n    padding: 0;\n    border: 0;\n    outline: 0;\n`);\n            this.v.insert(css.getDOM());\n\n            this.textArea = new v({ tagName: 'textarea', value: dataNode.getData()});\n            this.textArea.on('keyup', e => {\n                const newVal = e.target.value;\n                if (dataNode.getData() === newVal) return;\n                s.e('state.update', {dataNode: this.dataNode, data: newVal});\n            });\n            this.v.insert(this.textArea.getDOM());\n            //e('>', [this.textArea, this.v]);\n        }\n        activate() {\n            this.v.show();\n            const parent = this.v.parent();\n        }\n        deactivate() { this.v.hide(); }\n        getV() { return this.v; }\n        close() { this.v.removeFromDom(); }\n    }\n}"}},"fs":{"js":"async () => {\n    const promise = (await import(\"node:fs\")).promises;\n    const {createReadStream, createWriteStream} = (await import(\"node:fs\"));\n\n    return class FS {\n    \n        //readFileNative = util.promisify(fs.readFile);\n        //writeFileNative = util.promisify(fs.writeFile);\n        // renameNative = util.promisify(fs.rename);\n        // mkdir = util.promisify(fs.mkdir);\n        // open = util.promisify(fs.open);\n        // close = util.promisify(fs.close);\n        constructor(logger) { this.logger = logger; }\n\n        async openFile(path, flags) { return await promise.open(path, flags); }\n        async closeFile(fd) { return await promise.close(fd); }\n        async readFile(path, encoding) { return await promise.readFile(path, encoding === undefined ? 'utf8' : encoding) }\n        async writeFile(path, data) { return await promise.writeFile(path, data) }\n        async rm(path) { return await promise.rm(path) }\n        async stat(path) { return await promise.stat(path) }\n\n        async watch(path) {\n            const p = (await import(\"node:fs\")).promises;\n            return p.watch(path);\n        }\n        async createReadStream(path, options) { return createReadStream(path, options); } //using old api because promise.createReadStream cause warnings\n        async createWriteStream(path, options) { return createWriteStream(path, options); }\n\n        async writeFileIfNotExistsCreate(path, data) {}\n        async readFileIfNotExistsCreate(path, defaultValue = '') {\n            if (!await this.exists(path)) {\n                await this.writeFile(path, defaultValue);\n                return defaultValue;\n            }\n            return await this.readFile(path);\n        }\n        async mv(oldPath, newPath) { return await this.renameNative(oldPath, newPath); }\n    \n        async readJSONIfNotExistsCreate(path) {\n            if (!this.exists(path)) {\n                await this.writeFile(path, '{}');\n                return {};\n            }\n            return JSON.parse(await this.readFile(path, 'utf8'));\n        }\n    \n        async exists(path) {\n            try {\n                await promise.access(path);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n\n        async mkDirIfNotExists(path) {\n            if (!await this.exists(path)) await promise.mkdir(path, {recursive: true});\n        }\n        async mkDir(path) { return await this.mkdir(path); }\n        async readDir(path) {\n            return new Promise((resolve) => {\n                fs.readdir(path, (err, files) => resolve(files));\n            });\n        }\n        rmSync(path) { fs.rmSync(path); }\n\n        extract() {\n            console.log(s.decompress);\n        }\n    }\n}"},"fsChangesSlicer":{"js":"async path => {\n    return {\n        isStarted: false,\n        ac: new AbortController,\n        start: async function () {\n            if (this.isStarted) return;\n            this.generator = await s.nodeFS.watch(path, {signal: this.ac.signal});\n            for await (const e of this.generator) if (this.slicer) await this.slicer(e);\n            s.l('s.fsChangesSlicer STARTED');\n            this.isStarted = true;\n        },\n        stop: function () { this.ac.abort(); }\n    }\n}"},"getTimestamp":{"js":"() => {\n        const dt = new Date;\n        let year = dt.getFullYear().toString().padStart(4, '0');\n        let day = dt.getDate().toString().padStart(2, '0');\n        let month = (dt.getMonth()+1).toString().padStart(2, '0')\n\n        return `${year}-${month}-${day} ${\n            dt.getHours().toString().padStart(2, '0')}:${\n            dt.getMinutes().toString().padStart(2, '0')}:${\n            dt.getSeconds().toString().padStart(2, '0')}`;\n    }"},"getTimeStr":{"js":"(milliseconds) => {\nconst d = new Date(null); d.setMilliseconds(milliseconds);\nreturn d.toISOString().slice(11, -1);\n}"},"httpClient":{"js":"() => {\n    return class HttpClient {\n\n        constructor(baseURL = '', headers = {}, options = {}) {\n\n            this.headers = headers;\n            if (!this.headers['Content-Type']) {\n                this.headers['Content-Type'] = 'application/json';\n            }\n            if (baseURL) this.baseURL = baseURL;\n        }\n\n        async rq(method, url, params, headers, options = {}) {\n            let timeoutId;\n            const controller = new AbortController(); if (options.timeout) timeoutId = setTimeout(() => controller.abort(), options.timeout);\n            if (!headers['Content-Type']) headers['Content-Type'] = 'application/json';\n\n            const fetchParams = {method, headers, signal: controller.signal};\n\n            if (method === 'POST') {\n                if (params instanceof ArrayBuffer) {\n                    fetchParams.body = params;\n                } else {\n                    fetchParams.body = headers['Content-Type'] === 'application/json' ? JSON.stringify(params) : this.strParams(params);\n                }\n            } else {\n                if (Object.keys(params).length) url += '?' + new URLSearchParams(params);\n            }\n\n            const response = await fetch(this.baseURL ? this.baseURL + url : url, fetchParams);\n            if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }\n\n            let res = { statusCode: response.status, headers: response.headers };\n            if (options.blob) res.data = await response.blob();\n            else {\n                const contentType = response.headers.get('content-type') ?? '';\n                res.data = contentType.startsWith('application/json') ? await response.json() : await response.text();\n            }\n            return res;\n        }\n\n        async get(url, params = {}, headers = {}, options = {}) { return await this.rq('GET', url, params, headers, options); }\n        async post(url, params = {}, headers = {}, options = {}) { return await this.rq('POST', url, params, headers, options); }\n        async postBuf(url, buffer, query, headers = {}) {\n            if (query) url += '?' + new URLSearchParams(query);\n            headers['Content-Type'] = 'application/octet-stream';\n\n            return await this.rq('POST', url, buffer, headers);\n        }\n        async delete(url, params = {}, headers = {}, options = {}) { return await this.rq('DELETE', url, params, headers, options); }\n        strParams(params) {\n            let str = '';\n            for (let k in params) str = str + k + '=' + params[k] + '&';\n            return str.length ? str.slice(0, -1) : '';\n        }\n        async getFile(url, fName) {\n            const fs = new (await s.f('9f0e6908-4f44-49d1-8c8e-10e1b0128858'));\n            const r = await fetch(url);\n            await fs.writeFile(fName, Buffer.from(await r.arrayBuffer()));\n        }\n    }\n\n}"},"isArray":{"js":"d => Array.isArray(d)"},"isEmptyObject":{"js":"obj => Object.keys(obj).length === 0"},"isObject":{"js":"d => typeof d === 'object' && !Array.isArray(d) && d !== null"},"isUUID":{"js":"str => str.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}/)"},"list":{"js":"async () => {\n    return class List {\n\n        list = [];\n\n        add(item, index = null) {\n\n            if (index !== null) {\n                if (typeof index !== 'number') throw Error(`Index type is [${typeof index}].`);\n                this.list.splice(index, 0, item);\n\n                return index;\n            }\n\n            this.list.push(item);\n\n            return this.getLength() - 1;\n        }\n        del(index) { this.list.splice(index, 1) };\n        delLast() { this.list.pop(); };\n        pop() { return this.list.pop() }\n        get(index) { return this.list[index]; }\n        getAll() { return this.list; }\n        getFirst() { return this.list[0]; }\n        getLast() { return this.list[this.getLastIndex()] }\n        getLastIndex() { return this.list.length - 1; }\n        getLength() { return this.list.length; }\n        isEmpty() { return this.getLength() === 0; }\n        iterate(f) {\n            for (let i = 0; i < this.list.length; i++) f(this.list[i], i);\n        }\n        reset() { this.list = []; }\n    }\n    \n}"},"os":{"js":"async () => {\n\n    const {spawn, exec} = (await import('node:child_process'));\n\n    return class OS {\n        constructor(logger) {\n            this.logger = logger;\n            this.proc = null;\n        }\n        async run(cmd, detached, shell, procCallback, closeCallback) {\n\n            let args = cmd.split(' ');\n            let firstArg = args.shift();\n\n            const p = spawn(firstArg, args, {shell, detached});\n            this.proc = p;\n            if (procCallback) await procCallback(p);\n\n            p.stdout.on('data', data => this.logger.info(data.toString().trim()));\n            p.stderr.on('data', data => this.logger.error(data.toString().trim()));\n            p.on('error', err => this.logger.error(err.toString()));\n            p.on('close', code => {\n                this.logger.info({m: 'Process close:', code})\n                if (closeCallback) closeCallback(code);\n            });\n        }\n\n        async ex(cmd) {\n            return new Promise((resolve, reject) => {\n                exec(cmd, (err, stdout, stderr) => resolve({err, stdout, stderr}));\n            });\n        }\n    }\n}"},"persistObject":{"js":"async () => {\n\n    const fs = new ( await (x('9f0e6908-4f44-49d1-8c8e-10e1b0128858')) );\n    \n    return class PersistObject {\n\n        constructor(path) {\n            this.path = path;\n            this.obj = {};\n        }\n        async init() {\n            if (this.initiated) return;\n            if (await fs.exists(this.path)) {\n                this.obj = JSON.parse(await fs.readFile(this.path));\n            } else {\n                await fs.writeFile(this.path, '{}');\n            }\n            this.initiated = 1;\n        }\n        async s(k, v) {\n            if (!this.initiated) await this.init();\n            this.obj[k] = v;\n            await fs.writeFile(this.path, JSON.stringify(this.obj));\n        }\n        async g(k) {\n            if (!this.initiated) await this.init();\n            return this.obj[k];\n        }\n        async d(k) {\n            if (!this.initiated) await this.init();\n            delete this.obj[k];\n            await fs.writeFile(this.path, JSON.stringify(this.obj));\n        }\n    }\n}\n\n\n\n\n\n"},"pipeAsync":{"js":"async (...args) => {\n    let r;\n    for (let i = 0; i < args.length; i++) r = await eval(`async () => ${args[i]}`) ();\n    return r;\n}"},"psListParser":{"js":"[object Object]"},"rqStateUpdate":{"js":"async (rq, rs) => {\n    let {token} = s.sys.rqGetCookies(rq);\n    if (!token) {\n        rs.writeHead(403).end('Access denied. userToken not found.');\n        return;\n    }\n    if (!s.sys.token) {\n        rs.writeHead(500).end('sys.token is not defined.');\n        return;\n    }\n\n    const loadFromDisk = async path => {\n        const isUserSpaceUpdate = path[0] === 'users' && path[1] && path[1].length > 0;\n        let username = path[1];\n\n        if (isUserSpaceUpdate && !s.users[username]) {\n\n            const dir = `state/users`;\n            await s.fs.mkDirIfNotExists(dir);\n            const userFile = `${dir}/${username}.json`;\n            if (await s.fsAccess(userFile)) {\n                const user = await s.nodeFS.readFile(userFile, 'utf8');\n                s.users[username] = JSON.parse(user);\n            }\n        }\n    }\n    const loadUserByUsername = async userName => {\n\n        if (!s.users[userName]) {\n            const dir = `state/users`;\n\n            await s.fs.mkDirIfNotExists(dir);\n            const userFile = `${dir}/${userName}.json`;\n            if (await s.fsAccess(userFile)) {\n                const user = await s.nodeFS.readFile(userFile, 'utf8');\n                s.users[userName] = JSON.parse(user);\n            } else {\n                s.users[userName] = {};\n            }\n        }\n    }\n    //todo load path from disc and put to s\n    const saveToDisk = async path => {\n        const isUserSpaceUpdate = path[0] === 'users' && path[1] && path[1].length > 0;\n        let username = path[1];\n        const usersDir = `state/users`;\n\n        if (isUserSpaceUpdate) {\n            //todo username can be to long or contain invalid symbols as filename\n            const path = `${usersDir}/${username}.json`;\n            s.l('dump: ' + path);\n            await s.nodeFS.writeFile(path, JSON.stringify(s.users[username]));\n        }\n    }\n    //todo instead of this use s.findParentAndK\n    const getParentNodeAndKey = path => {\n        let node, k;\n        if (path.length === 1) {\n            node = s;\n            k = path[0];\n        } else {\n            node = s.find(path.slice(0, -1));\n            k = path.at(-1);\n        }\n        if (!node || !k) { //todo return error instead of using rs\n            rs.s(`node not found or path is invalid [${path}]`); return {};\n        }\n        return {node, k};\n    }\n    const updateNode = (path, v) => {\n        const {node, k} = getParentNodeAndKey(path);\n        if (!node || !k) return;\n\n        //test();\n\n        //todo check operation for Array\n        if (k === 'js') {\n            eval(v); //use parser or lister for check syntax\n            delete node[s.sys.SYMBOL_FN];\n        }\n        node[k] = v;\n    }\n    const cp = (oldPath, newPath) => {\n        const {node, k} = getParentNodeAndKey(oldPath);\n        if (!node || !k) {\n            s.l(`No node or k. oldPath [${oldPath}]`)\n            return;\n        }\n        let parentNodeAndKey = getParentNodeAndKey(newPath);\n        let node2 = parentNodeAndKey.node;\n        let k2 = parentNodeAndKey.k;\n        if (!node2 || !k2) {\n            s.l(`No node2 or k2. newPath [${newPath}]`)\n            return;\n        }\n        node2[k2] = node[k];\n        return {node, k};\n    }\n    const rm = path => {\n        const {node, k} = getParentNodeAndKey(path);\n        if (!node || !k) return;\n        delete node[k];\n        if (k === 'js') delete node[s.sys.SYMBOL_FN];\n    }\n    const checkSpaceLimit = (path, v, op) => {\n\n        if (op === 'cp' ) {\n            //todo pass here oldPath, newPath\n            //todo cp can make circular references, so need processing of circular references\n        } else if (op === 'up') {\n            const {node, k} = getParentNodeAndKey(path);\n            if (!node || !k) return;\n\n            const nodeClone = structuredClone(node);\n            nodeClone[k] = v;\n            const bytes = Buffer.byteLength(JSON.stringify(nodeClone));\n            const oneMB = 1 * 1024 * 1024;\n            if (bytes > oneMB) return false;\n        }\n        return true;\n    }\n\n    const isSysToken = s.sys.token === token;\n    const {users} = await s.sys.getSecrets();\n    let userName = users[token];\n\n    if (userName) await loadUserByUsername(userName);\n\n    if (!isSysToken && !userName) {\n        rs.writeHead(403).end('Sys token or user not found.');\n        return;\n    }\n\n    const {cmds, updateId} = await s.sys.rqParseBody(rq);\n    let batch = cmds;\n\n    const updateIds = s.sys.netUpdateIds;\n    if (updateId && updateIds.get(updateId)) {\n        s.l(`Update already received before. [${updateId}]`);\n        return;\n    }\n    if (!cmds || !Array.isArray(cmds)) {\n        rs.s(`cmds is not valid ${cmds}`);\n        return;\n    }\n\n    const user = s.users[userName];\n    if (user && !user._sys_) user._sys_ = {};\n    //for (let i in user) if (user[i] === undefined) delete user[i];\n\n    for (let i = 0; i < batch.length; i++) {\n\n        const update = batch[i];\n        if (!s.f('sys.isObject', update)) {\n            rs.s(`cmd is not valid ${update}.`);\n            return;\n        }\n        const {path, oldPath, newPath, v, op} = update;\n\n        //validate pathes, or oldPath, newPath\n        let result = isSysToken;\n        if (!result) {\n            if (oldPath && newPath) {\n                const checkA = await s.f('sys.checkUpdatePermission', oldPath, userName, user);\n                const checkB = await s.f('sys.checkUpdatePermission', newPath, userName, user);\n                if (checkA !== true || checkB !== true) {\n                    rs.writeHead(403).end(`Access denied. ${checkA}`);\n                    return;\n                }\n                result = true;\n            } else {\n                result = await s.f('sys.checkUpdatePermission', path, userName, user);\n            }\n        }\n        if (result !== true) {\n            rs.writeHead(403).end(`Access denied. ${result}`);\n            return;\n        }\n\n        //todo validate path, oldPath, newPath\n        //todo get path from disc if exists. check size of memory\n        if (path) {\n            //await loadFromDisk(path);\n        } else if (newPath && oldPath) {\n            await loadFromDisk(oldPath);\n            await loadFromDisk(newPath);\n        }\n\n        if (!checkSpaceLimit(path, v, op)) {\n            rs.writeHead(403).end(`Space limit reached.`);\n            return;\n        }\n\n        //todo case with long arrays can be really slow, so need to make limits\n        //todo case if it not object, but MAP or SET\n        if (op === 'rm') {\n            rm(path);\n        } else if (op === 'cp') {\n            //todo cp can make circular references, so need processing of circular references\n            //cp(oldPath, newPath);\n        } else if (op === 'mv') {\n            //todo prevent mv of array keys\n            const {node, k} = cp(oldPath, newPath);\n            delete node[k];\n        } else if (op === 'set' || op === 'up') {\n            updateNode(path, v);\n        } else if (op === 'merge') {\n            const node = s.find(path);\n            s.merge(node, v);\n        }\n\n        if (path) {\n            await saveToDisk(path);\n        } else if (newPath && oldPath) {\n            //await saveToDisk(oldPath);\n            await saveToDisk(newPath);\n        }\n    }\n\n    rs.s('ok');\n    //await s.f('sys.netUpdate', {cmds, updateId}, token, true);\n}"},"stringBytesLength":{"js":"obj => {\n        const size = Buffer.byteLength(obj);\n        return {b: size, kb: size / 1024, mb: size / 1024 / 1024};\n    }"},"ui":{"btn":{"js":"async () => {\n    return async (txt, color) => {\n        const b = new s.V({txt, tagName: 'button'});\n        return b;\n    }\n}"},"input":{"js":"async () => {\n    return class Input {\n        constructor() { this.win = window; }\n        disableHandlers() {\n            this.win.onkeydown = null;\n            this.win.onkeyup = null;\n            this.win.onclick = null;\n            this.win.ondblclick = null;\n            this.win.onpointermove = null;\n            this.win.onpointerup = null;\n            this.win.onresize = null;\n            this.win.oncontextmenu = null;\n        }\n        onKeyDown(fn) { this.win.onkeydown = fn; }\n        onKeyUp(fn) { this.win.onkeyup = fn; }\n        onClick(fn) { this.win.onclick = fn; }\n        onDblClick(fn) { this.win.ondblclick = fn; }\n        onMouseMove(fn) { this.win.onpointermove = fn; }\n        onMouseUp(fn) { this.win.onpointerup = fn; }\n        onResize(f) { this.win.onresize = f; }\n        onContextMenu(f) { this.win.oncontextmenu = f; }\n    }\n    \n}"},"view":{"js":"() => {\n    return class V {\n\n        constructor(data) {\n            this.data = data || {};\n        }\n        getId() { return this.dom.id; }\n        attachShadow() {\n            this.shadow = this.getDOM().attachShadow({ mode: \"open\" });\n        }\n\n        insert(dom) {\n            if (this.shadow) {\n                this.shadow.appendChild(dom);\n            }\n        }\n\n        on(eventName, callback) { this.getDOM().addEventListener(eventName, callback); }\n        off(eventName, callback) { this.getDOM().removeEventListener(eventName, callback); }\n        getValue() { return this.getDOM().value; }\n        getVal() { return this.getValue(); }\n        setVal(val) { this.getDOM().value = val; }\n\n        setDOM(dom) { this.dom = dom; }\n        getDOM() {\n            if (this.dom) return this.dom;\n\n            this.dom = document.createElement(this.data.tagName || 'div');\n\n            if (this.data.style) {\n                for (let key in this.data.style) this.dom.style[key] = this.data.style[key];\n            }\n\n            if (this.data.id) this.dom.id = this.data.id;\n            if (this.data.class) {\n                if (Array.isArray(this.data.class)) {\n                    this.dom.className = this.data.class.join(' ');\n                } else {\n                    this.dom.className = this.data.class;\n                }\n            }\n            if (this.data.txt !== undefined) this.dom.innerText = this.data.txt;\n            if (this.data.value !== undefined) this.dom.value = this.data.value;\n\n            return this.dom;\n        }\n\n        getTxt() { return this.getDOM().innerText; }\n        setTxt(txt) { this.getDOM().innerText = txt; }\n\n        setHtml(txt) { this.getDOM().innerHTML = txt; }\n\n        setAttr(k, v) {\n            this.getDOM().setAttribute(k, v);\n            return this;\n        }\n        removeAttr(k) { this.getDOM().removeAttribute(k); }\n        getAttr(k) { return this.getDOM().getAttribute(k); }\n        getHtml() { return this.getDOM().innerHTML; }\n        setStyles(data) { for (let k in data) this.getDOM().style[k] = data[k]; }\n        getStyle(k) { return this.getDOM().style[k]; }\n        getComputedStyle(k) {\n            return window.getComputedStyle(this.getDOM(), null).getPropertyValue(k);\n        }\n\n        addShift() {\n            let dom = this.dom;\n            let x = dom.style.left ? parseInt(dom.style.left.replace('px', ''), 10) : 0\n            let newX = (x + 100) + 'px';\n\n            this.data.style.left = newX;\n            dom.style.left = newX;\n        }\n        setCoords(x = 0, y = 0) {\n\n            if (!this.data.style) this.data.style = {};\n\n            if (x) {\n                this.data.style.left = x + 'px';\n                this.dom.style.left = x + 'px';\n            }\n            if (y) {\n                this.data.style.top = y + 'px';\n                this.dom.style.top = y + 'px';\n            }\n        }\n        setSizes(width, height) {\n            if (width) this.dom.style.width = width + 'px';\n            if (height) this.dom.style.height = height + 'px';\n        }\n        getSizes() { return this.dom.getBoundingClientRect() }\n        getSizesAbsolute() {\n            let sizes = this.dom.getBoundingClientRect();\n            let scrollX = window.scrollX;\n            let scrollY = window.scrollY;\n\n            return {\n                height: sizes.height,\n                width: sizes.width,\n\n                top: sizes.top + scrollY,\n                bottom: sizes.bottom + scrollY,\n                left: sizes.left + scrollX,\n                right: sizes.right + scrollX,\n                x: sizes.x + scrollX,\n                y: sizes.y + scrollY,\n            }\n        }\n        getChildren() { return this.dom.children }\n        getChildrenCount() { return this.dom.children.length }\n        select() {\n            this.dom.style.border = '2px solid black';\n            this.dom.style.padding = '4px';\n        }\n        unselect() {\n            this.dom.style.border = '1px solid black';\n            this.dom.style.padding = '5px';\n        }\n        addClass(className) { this.getDOM().classList.add(className); }\n        hasClass(className) { return this.dom.classList.contains(className); }\n        removeClass(className) { this.getDOM().classList.remove(className); }\n        isShowed() { return !this.isHidden(); }\n        isHidden() { return this.dom.classList.contains('hidden'); }\n        toggleDisplay() { this.getDOM().classList.toggle('hidden'); }\n        show() { this.getDOM().classList.remove('hidden'); }\n        hide() { this.getDOM().classList.add('hidden'); }\n\n        visibilityShow() { this.getDOM().classList.remove('visibilityHidden'); }\n        visibilityHide() { this.getDOM().classList.add('visibilityHidden'); }\n\n        isChecked() { return this.getDOM().checked; }\n        removeFromDom() { this.dom.parentNode.removeChild(this.dom); }\n        remove() { this.removeFromDom(); }\n        toggleEdit() {\n            if (this.dom.contentEditable === 'true') {\n                this.dom.removeAttribute('contentEditable');\n                this.data.txt = this.dom.innerText;\n\n                return false;\n            } else {\n                this.dom.contentEditable = 'true';\n                this.dom.focus();\n\n                return true;\n            }\n        }\n        iEditMod() { this.getDOM().contentEditable = 'true' }\n        oEditMode() { this.getDOM().contentEditable = 'false' }\n        focus() { this.getDOM().focus(); }\n        clear() { this.getDOM().innerHTML = ''; }\n\n        parentDOM() { return this.getDOM().parentNode; }\n        nextDOM() { return this.getDOM().nextSibling; }\n        prevDOM() { return this.getDOM().previousSibling; }\n\n        parent() {\n            const v = new V;\n            v.setDOM(this.getDOM().parentNode);\n            return v;\n        }\n\n        getDOMIndex() {\n            const parent = this.parentDOM();\n            return Array.prototype.indexOf.call(parent.children, this.getDOM());\n        }\n\n        getDomIndex() {\n            return Array.prototype.indexOf.call(parent.children, child);\n        }\n\n        scrollDown() {\n            const dom = this.getDOM();\n            dom.scrollTop = dom.scrollHeight;\n        }\n    }\n\n}"}},"unixTs":{"js":"() => Math.floor(Date.now() / 1000)"},"uuid":{"js":"() => {\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) return crypto.randomUUID();\n    const s4 = () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}"},"rqGetToken":{"js":"(rq, tokenName) => {\n        if (!rq.headers.cookie || rq.headers.cookie.length < 1) return;\n\n        const cookies = rq.headers.cookie.split(';');\n        for (let i in cookies) {\n            const cookieKV = cookies[i].trim().split('=');\n            if (cookieKV[0] === tokenName && cookieKV[1]) {\n                return cookieKV[1].trim();\n            }\n        }\n    }"},"getMemoryUsage":{"js":"() => {\n    const mem = s.process.memoryUsage().heapUsed / 1024 / 1024;\n    return `memory ${Math.round(mem * 100) / 100} MB`;\n}"}}